#  索引

---
## 1 什么是索引

索（Index）引用来排序数据以加快搜索和排序操作的速度。简单地说，索引是一个指向表中数据的指针。一个数据库中的索引与一本书后边的索引是非常相似的。

例如，一般本书总是会安装其内容划分为多个章节，并建立索引，如果你对某部分感兴趣你可以直接根据索引来定义内容，如果没有索引，那么你需要从第一页开始翻阅查找你感兴趣的内容，直到你找到为止，这种方式的效率是非常低的。数据库的索引与书本的索引有相似之处。

>使索引有用的因素就是恰当的排序。找出书中词汇的困难不在于必须进行多少搜索，而在于书的内容没有按词汇排序。如果书的内容像字典一样排序，则索引没有必要。
数据库索引的作用也一样。**主键数据总是排序的**，这是DBMS的工作。因此，按主键检索特定行总是一种快速有效的操作。
但是，搜索其他列中的值通常效率不高。例如，如果想搜索住在某个州的客户，怎么办？因为表数据并未按州排序，DBMS必须读出表中所有 行（从第一行开始），看其是否匹配。这就像要从没有索引的书中找出词汇一样。解决方法是使用索引。可以在一个或多个列上定义索引，使DBMS保存其内容的一个排过序的列表。在定义了索引后，DBMS以使用书的索引类似的方法使用它。DBMS搜索排过序的索引，找出匹配的位置，然后检索这些行。——《SQL必知必会》

---
## 2 在开始创建索引前，应该记住以下内容

 **索引有助于加快 SELECT 查询和 WHERE 子句**，但它会**减慢使用 UPDATE 和 INSERT 语句时的数据输入**。同时索引还会增加数据库的磁盘占用量，索引可以创建或删除，但不会影响数据。

虽然索引的目的在于提高数据库的性能，但这里有几个情况需要避免使用索引。使用索引时，应重新考虑下列准则：

*   索引用于数据过滤和数据排序。如果你经常以某种特定的顺序排序数据（比如 `>, <, =, >=, <=,order by,group by`），则该数据可能适合做索引。
*   索引不应该使用在数据量较小的表上。
*   索引不应该使用在有频繁的大批量的更新或插入操作的表上。
*   索引不应该使用在含有大量的 NULL 值的列上。
*   索引不应该使用在频繁操作的列上。

---
## 3 索引分类

- 直接创建索引和间接创建索引
    - 直接创建索引：使用SQL语句创建的索引。
    - 间接创建索引：使用主键和唯一性约束会间接创建索引，主键默认为唯一索引。
- 普通索引和唯一索引
    - 普通索引就是我们平时创建的索引
    - 唯一索引：保证在索引列中的全部数据都是唯一的，对聚簇索引和非聚簇索引都可以使用，`CREATE UNIQUE COUSTERED INDEX index_name ON table_name(column_name)`
- 单列索引和复合索引
    - 单列索引：表中的索引只包含一个列
    - 复合索引：表中的索引只包含多个列，`CREATE INDEX index_name ON table_name(first_name,  last_name)`，first_name 为前导列
- 聚簇索引和非聚簇索引
    - 聚簇索引：索引的顺序就是数据存放的顺序，一张表只能有一个聚簇索引
    - 非聚簇索引：索引顺序与数据物理排列顺序无关


---
## 4 实例

如果我们经常使用 name 来查询 students 表中的学生信息：

```
select * from students where name='Jake'
```

那么就可以为name字段创建索引，语法为：

```
create index [uniqu] index_name on table_name (column_list)

index_name 表示索引名称
table_name 表示在那张表上创建索引
uniqe 表示要求索引中所有的字段必唯一
column_list 表示字段列表
```

为name创建索引
```
create stu_name_index on students (name collate nocase);

collate nocase表示排序规则与大小写无关
```
>collate在sql中是用来定义排序规则的。排序规则其实就是当比较两个字符串时，根据某种规则来确定哪个比较大，是否相等。各个数据库支持不同的排序规则。nocase则表示排序时忽略大小写。

---
## 5 索引使用规则

创建索引比较简单，但是我们并不是直接操作在索引上，我们操作的依然是表，但我们操作时，SQLite根据我条件来选择是否使用索引，**当查询条件是与索引的字段判等时**，数据库则使用索引来加速，**如果有多个索引字段，那么出现第一个不是判断等的逻辑之后，后续字段就不会使用索引**。比如：

```
//test表中有四个字段a b c d
create index indexTest on test (a,b,c)

//实例1：使用sql进行查询
select * from test where a=1 and c=3
//那么只有a会使用索引，而c则不会，因为它们中间的b索引断了

//实例2：使用sql进行查询
select * from test where a=1 and b > 1 and c=3
//此时也只有a会使用索引，因为b的条件是大于而不是判等，所以后续的字段也不会使用索引
```

所以对于复合索引，把使用最频繁的列做为前导列(索引中第一个字段)。

---
## 引用

- [具体参考](http://udn.yyuap.com/doc/wiki/project/sqlite/sqlite-index.html)
- [性能优化之数据库优化](http://www.trinea.cn/android/database-performance/)
