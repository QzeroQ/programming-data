# 崩溃优化（上）：关于“崩溃”那些事儿

## 1 Android 的两种崩溃

Android 崩溃分为 Java 崩溃和 Native 崩溃。

- Java 崩溃就是在 Java 代码中，出现了未捕获异常，导致程序异常退出。
- Native 崩溃一般都是因为在 Native 代码中访问非法地址，也可能是地址对齐出现了问题，或者发生了程序主动 abort，这些都会产生相应的 signal 信号，导致程序异常退出。

“崩溃”就是程序出现异常，而一个产品的崩溃率，跟我们如何捕获、处理这些异常有比较大的关系。Java 异常容易捕获，难点在于 Native 异常捕获。

### Native 崩溃的捕获流程

**掌握 Native 崩溃机制的基本知识**：

- 参考[Android 平台 Native 代码的崩溃捕获机制及实现](https://mp.weixin.qq.com/s/g-WzYF3wWAljok1XjPoo7w?)

**一个完整的 Native 崩溃从捕获到解析要经历哪些流程**：

- 编译端。编译 C/C++ 代码时，需要将带符号信息的文件保留下来。
- 客户端。捕获到崩溃时候，将收集到尽可能多的有用信息写入日志文件，然后选择合适的时机上传到服务器。
- 服务端。读取客户端上报的日志文件，寻找适合的符号文件，生成可读的 C/C++ 调用栈。

![Native 崩溃从捕获到解析流程](images/ch01_native_crash_catch_process.jpg)

### Native 崩溃捕获的难点

1. Chromium 的 [Breakpad](https://chromium.googlesource.com/breakpad/breakpad/+/master) 是目前 Native 崩溃捕获中最成熟的方案。
2. 如果只想在 90% 的情况可靠，那大部分的代码的确可以砍掉；但如果想达到 99%，在各种恶劣条件下依然可靠，后面付出的努力会远远高于前期。

三个流程中，最核心的是**怎么样保证客户端在各种极端情况下依然可以生成崩溃日志**。因为在崩溃时，程序会处于一个不安全的状态，如果处理不当，非常容易发生二次崩溃。

**生成崩溃日志时会有哪些比较棘手的情况呢**？

1. 情况一：文件句柄泄漏，导致创建日志文件失败，怎么办？
   1. 应对方式：我们需要提前申请文件句柄 fd 预留，防止出现这种情况。
2. 情况二：因为栈溢出了，导致日志生成失败，怎么办？
   1. 应对方式：为了防止栈溢出导致进程没有空间创建调用栈执行处理函数，我们通常会使用常见的 signalstack。在一些特殊情况，我们可能还需要直接替换当前栈，所以这里也需要在堆中预留部分空间。
3. 情况三：整个堆的内存都耗尽了，导致日志生成失败，怎么办？
   1. 应对方式：这个时候我们无法安全地分配内存，也不敢使用 stl 或者 libc 的函数，因为它们内部实现会分配堆内存。这个时候如果继续分配内存，会导致出现堆破坏或者二次崩溃的情况。Breakpad 做的比较彻底，重新封装了[Linux Syscall Support](https://chromium.googlesource.com/linux-syscall-support/)，来避免直接调用 libc。
4. 情况四：堆破坏或二次崩溃导致日志生成失败，怎么办？
   1. 应对方式：Breakpad 会从原进程 fork 出子进程去收集崩溃现场，此外涉及与 Java 相关的，一般也会用子进程去操作。这样即使出现二次崩溃，只是这部分的信息丢失，我们的父进程后面还可以继续获取其他的信息。在一些特殊的情况，我们还可能需要从子进程 fork 出孙进程。

**Breakpad 也存在着一些问题**：

- 例如生成的 minidump 文件是二进制格式的，包含了太多不重要的信息，导致文件很容易达到几 MB。
- minidump 也不是毫无用处，它有一些比较高级的特性，比如[使用 gdb 调试](https://www.chromium.org/chromium-os/packages/crash-reporting/debugging-a-minidump)、可以看到传入参数等。
- Chromium 未来计划使用 Crashpad 全面替代 Breakpad，但目前来说还是 “too early to mobile”。

### 选择合适的崩溃上报服务

对于很多中小型公司来说，可能无法自己实现一套复杂的崩溃上报系统，可以选择第三方服务：

- 腾讯的Bugly
- 阿里的啄木鸟平台
- 网易云捕
- Google 的 Firebase
- 等待...

## 2 如何客观地衡量崩溃

**统计各种崩溃率**：

- PV 崩溃率
- 启动崩溃率
- 重复崩溃率

**UV 崩溃率**：要衡量一个指标，首先要统一计算口径。如果想评估崩溃造成的用户影响范围，我们会先去看 UV 崩溃率。只要用户出现过一次崩溃就会被计算到，所以 UV 崩溃率的高低会跟应用的使用时长有比较大的关系。

```math
UV 崩溃率 = 发生崩溃的 UV / 登录 UV
```

**为什么要单独统计启动崩溃率呢**？

- 因为启动崩溃对用户带来的伤害最大，应用无法启动往往通过热修复也无法拯救。
- 闪屏广告、运营活动，很多应用启动过程异常复杂，又涉及各种资源、配置下发，极其容易出现问题。
- 微信读书、蘑菇街、淘宝、天猫这些“重运营”的应用都有使用一种叫作“[安全模式](https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247488429&idx=1&sn=448b414a0424d06855359b3eb2ba8569&source=41#wechat_redirect)”的技术来保障客户端的启动流程，在监控到客户端启动失败后，给用户自救的机会。

>安全模式，比如在启动时会检查上次应用的退出类型，如果检查连续三次异常退出，则做响应的操作。

### 避免技术指标过于 KPI 化

反例：

- 程序员 B 对所有线程、任务都封装了一层 try catch，“消化”掉了所有 Java 崩溃。至于程序是否会出现其他异常表现，这是上帝要管的事情，反正我是实现了“千分之一”的目标。
- 程序员 C 认为 Native 崩溃太难解决，所以他想了一个“好方法”，就是不采集所有的 Native 崩溃，美滋滋地跟老板汇报“万分之一”的工作成果。

技术指标过于 KPI 化，是国内比较明显的一个现象。**崩溃率只是一个数字，我们的出发点应该是让用户有更好的体验**。

## 3 如何客观地衡量稳定性

### ANR

处理了崩溃，我们还会经常遇到 ANR（Application Not Responding，程序没有响应）这个问题。出现 ANR 的时候，系统还会弹出对话框打断用户的操作，这是用户非常不能忍受的。这又带来另外一个问题，我们怎么去发现应用中的 ANR 异常呢？通常有两种做法。

**1 使用 FileObserver 监听 /data/anr/traces.txt 的变化**：

- 很多高版本的 ROM，已经没有读取这个文件的权限了。
- 海外可以使用 Google Play 服务。
- 国内微信利用 [Hardcoder](https://mp.weixin.qq.com/s/9Z8j3Dv_5jgf7LDQHKA0NQ?) 框架向厂商获取了更大的权限。

**2 监控消息队列的运行时间**：

- 这个方案无法准确地判断是否真正出现了 ANR 异常，也无法得到完整的 ANR 日志。更应该放到卡顿的性能范畴。

### 应用异常退出

除了常见的崩溃，还有一些会导致应用异常退出的情况，在讨论什么是异常退出之前，我们先看看都有哪些应用退出的情形：

- 主动自杀。`Process.killProcess()`、`exit()` 等。崩溃。
- 出现了 Java 或 Native 崩溃。
- 系统重启；系统出现异常、断电、用户主动重启等，我们可以通过比较应用开机运行时间是否比之前记录的值更小。
- 被系统杀死。被 low memory killer 杀掉、从系统的任务管理器中划掉等。
- ANR。

**异常率**：在应用启动的时候设定一个标志，在主动自杀或崩溃后更新标志，这样下次启动时通过检测这个标志就能确认运行期间是否发生过异常退出。对应上面的五种退出场景，我们排除掉主动自杀和崩溃（崩溃会单独的统计）这两种场景，希望可以监控到剩下三种的异常退出，理论上这个异常捕获机制是可以达到 100% 覆盖的。通过这个异常退出的检测，可以反映如 ANR、low memory killer、系统强杀、死机、断电等无法正常捕获到的问题。当然异常率会存在一些误报，比如用户从系统的任务管理器中划掉应用。对于线上的大数据来说，还是可以帮助我们发现代码中的一些隐藏问题。

所以就得到了一个新的指标来衡量应用的稳定性，即异常率：

```log
UV 异常率 = 发生异常退出或崩溃的 UV / 登录 UV
```

通过异常率我们可以比较全面的评估应用的稳定性，对于线上监控还需要完善崩溃的报警机制。

## 4 总结

1. Android 的两种崩溃， Native 崩溃的捕获流程和一些难点。
2. **崩溃率**应该如何去计算，崩溃率的高低跟应用时长、复杂度、收集 SDK 有关。
3. 目前 **ANR** 采集的方式以及遇到的问题。
4. 一个新的稳定性监控指标：**异常率**。

作为技术人员，我们不应该盲目追求崩溃率这一个数字，应该以用户体验为先，如果强行去掩盖一些问题往往更加适得其反。我们不应该随意使用 try catch 去隐藏真正的问题，要从源头入手，了解崩溃的本质原因，保证后面的运行流程。在解决崩溃的过程，也要做到由点到面，不能只针对这个崩溃去解决，而应该要考虑这一类崩溃怎么解决和预防。

## 5 实践

使用 Breakpad 来捕获一个 Native 崩溃。

### 下载和编译 Breakpad

按照 [Breakpad](https://github.com/google/breakpad) 说明下载 Breakpad，如果 git 无法访问 GoogleSource，是因为设置了代理，先配置一下 git 即可:

```bash
# 下面 `192.168.4.12:8080` 不同的 VPN 可能不一致。
git config --local http.proxy 192.168.4.12:8080
```

整体步骤：

```bash
# 设置代理
git config --local http.proxy 192.168.4.12:8080

# 下载 depot_tools 工具
git clone https://chromium.googlesource.com/chromium/tools/depot_tools
# 解压后配置路径
export PATH=$PATH:/mnt/d/linux/depot_tools

# 如果没有安装 python 2.7.x
apt install python

# 下载 breakpad
fetch breakpad
# 配置和编译
./configure && make
```

### 分析崩溃

```bash
# 根据 minidump 文件生成堆栈跟踪log
./minidump_stackwalk a9663bf9-2eff-40ca-2346cf9d-f30b238d.dmp > crashLog.txt
```

得到信息如下：

```log
Operating system: Android
                  0.0.0 Linux 4.9.111 #1 SMP PREEMPT Wed Apr 10 02:52:24 CST 2019 aarch64
CPU: arm64
     8 CPUs

GPU: UNKNOWN

Crash reason:  SIGSEGV /SEGV_MAPERR
Crash address: 0x1000300020005
Process uptime: not available

Thread 0 (crashed)
 0  libnative-lib.so + 0x550
     x0 = 0x0001000300020005    x1 = 0x0000007fd55ce864
     x2 = 0x0000000012d995b0    x3 = 0x00000078b2a98e14
     x4 = 0x0000007fd55ce844    x5 = 0x0000000000000000
     x6 = 0x0000007fd55ce7e0    x7 = 0x00000078b5415c00
     x8 = 0x0000000000000003    x9 = 0x25fa764e80501f98
    x10 = 0x0000000000430000   x11 = 0x00000078b2e6d6d8
    x12 = 0x000000793b910510   x13 = 0x2d00dd85dff99863
    x14 = 0x000000793b511000   x15 = 0xffffffffffffffff
    x16 = 0x00000078967a253c   x17 = 0x0000007935c43cb4
    x18 = 0x0000000000000000   x19 = 0x00000078b5415c00
    x20 = 0x0000000000000000   x21 = 0x00000078b5415c00
    x22 = 0x0000007fd55ceb30   x23 = 0x00000078974e5d24
    x24 = 0x0000000000000004   x25 = 0x000000793bc805e0
    x26 = 0x00000078b5415ca0   x27 = 0x0000000000000001
    x28 = 0x0000007fd55ce860    fp = 0x0000007fd55ce860
     lr = 0x00000078b2d92fe4    sp = 0x0000007fd55ce820
     pc = 0x00000078967a2550
    Found by: given as instruction pointer in context

... 省略...
```

符号解析：用 ndk 中提供的 addr2line 来根据地址进行一个符号反解的过程：

```bash
# 输入命令，进入交互模式
D:\dev_tools\android-ndk-r13b-windows-x86_64\android-ndk-r13b\toolchains\aarch64-linux-android-4.9\prebuilt\windows-x 86_64\bin\aarch64-linux-android-addr2line.exe -f -C -e D:\codes\github\Programming-Notes\00-Code\Android\AndroidAdvanceWithGeektime\Chapter01\app\build\intermediates\transforms\mergeJniLibs\debug\0\lib\arm64-v8a\libnative-lib.so

# 输入地址，addr2line 会输出代码行号
0x550
Java_com_dodola_breakpad_MainActivity_makeCrash
D:\codes\github\Programming-Notes\00-Code\Android\AndroidAdvanceWithGeektime\Chapter01\app\src\main\cpp/native-lib.cpp:8
```

具体参考

- [AndroidAdvanceWithGeektime/Chapter01](https://github.com/AndroidAdvanceWithGeektime/Chapter01)
- [作业](../../00-Code/Android\AndroidAdvanceWithGeektime/Chapter01/README.md)

## 6 扩展

- [Android 平台 Native 代码的崩溃捕获机制及实现](https://mp.weixin.qq.com/s/g-WzYF3wWAljok1XjPoo7w?)
  - Native 异常捕获框架
  - 类 Unix 系统移除处理机制、如何捕获异常
- [Breakpad](https://chromium.googlesource.com/breakpad/breakpad/+/master)
  - Breakpad 是什么
  - Breakpad 能做什么
  - 阅读 Breakpad 相关代码，掌握其原理
- [安全模式](https://mp.weixin.qq.com/s?__biz=MzUxMzcxMzE5Ng==&mid=2247488429&idx=1&sn=448b414a0424d06855359b3eb2ba8569&source=41#wechat_redirect)
  - 什么是安全模式
  - 如何实现
