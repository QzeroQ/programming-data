# RxJava 入门

---
## 1 Rx 简介

RxJava官方介绍是：**Reactive Extensions for the JVM , a library for composing asynchronous and event-based programs using observable sequences for the Java VM**"，既 **JVM上的响应式扩展，一个在 Java VM 上使用`可观测的序列`来编写`异步的`、`基于事件`的程序的库**

### RX 历史

ReactiveX 是 Reactive Extensions 的缩写，一般简写为 Rx，最初是 LINQ(Language Integrated Query) 的一个扩展，由微软的架构师 Erik Meijer 领导的团队开发，在 2012 年 11 月开源，Rx 是一个编程模型，目标是 **提供一致的编程接口**，帮助开发者更方便的处理异步数据流，Rx 的大部分语言库由 ReactiveX 组织负责维护，比较流行的有 RxJava/RxJS/Rx.NET，社区网站是 `reactivex.io`。

### 什么是 ReactiveX

- **微软定义**：Rx是一个函数库，让开发者可以利用可观察序列和LINQ风格查询操作符来编写异步和基于事件的程序，使用Rx，开发者可以用Observables表示异步数据流，用LINQ操作符查询异步数据流， 用Schedulers参数化异步数据流的并发处理，Rx可以这样定义：`Rx = Observables + LINQ + Schedulers`。
- `reactivex.io`定义：Rx是一个使用可观察数据流进行异步编程的编程接口，ReactiveX结合了`观察者模式、迭代器模式和函数式编程的精华`。

具体可以参考 [ReactiveX宣言](https://www.reactivemanifesto.org/) ：ReactiveX 不仅仅是一个编程接口，它是一种编程思想的突破，它影响了许多其它的程序库和框架以及编程语言。

RxJava使用了`观察者模式+迭代器模式+函数式编程`

- 观察者模式：RxJava 扩展了观察者模式，通过使用可观察的对象序列流来表述一系列事件，订阅者进行观察并对序列流做出反应（或持久化或输出显示等等）。
- 迭代器模式：借鉴迭代器模式，对多个对象序列进行迭代输出，订阅者可以依次处理不同的对象序列。
- 函数式编程：使用函数式编程思想(functional programming)，极大简化问题解决的步骤。

### 响应式与函数式

响应式编程：

- 事件驱动：各组件之间通过异步的消息交换实现松耦合、彼此隔离和位置透明。
- 可伸缩性：对于变化的负载，系统保持可响应性。能够依据负载的多少自动地调整所占用的资源。
- 可靠性：即使发生故障，系统应该仍然是有响应的。故障应该被限制于特定的范围之内，不依赖于客户端去处理故障。
- 及时响应：系统必须尽可能快地响应并保证它所提供的服务的质量是有保障的。

函数式编程：

- 纯函数：没有副总用的函数，对于没有副作用的函数，不管多个线程调用多少次，总能得到相同的结果。
- 高阶函数：返回函数的函数。
- 函数是第一等公民：函数可以成为另一个函数的参数。

RxJava 综合应用了函数式与响应式编程思想。

### Rx模式

使用观察者模式：

*   创建：Rx可以方便的创建事件流和数据流
*   组合：Rx使用查询式的操作符组合和变换数据流
*   监听：Rx可以订阅任何可观察的数据流并执行操作

简化代码：

*   函数式风格：对可观察数据流使用无副作用的输入输出函数，避免了程序里错综复杂的状态
*   简化代码：Rx的操作符通通常可以将复杂的难题简化为很少的几行代码
*   异步错误处理：传统的try/catch没办法处理异步计算，Rx提供了合适的错误处理机制
*   轻松使用并发：Rx的Observables和Schedulers让开发者可以摆脱底层的线程同步和各种并发问题

使用 Observable 的优势：

- Observable可组合：Rx的Observable一开始就是为组合异步数据流准备的，可以轻易组合带条件的异步执行流程。
- Observable更灵活：observable 是一个抽象概念，适用于任何场景。
- Observable无偏见：Rx对于对于并发性或异步性没有任何特殊的偏好，Observable可以用任何方式实现，线程池、事件循环、非阻塞IO、Actor模式等。
- 避免了回调嵌套的地狱

Rx 本来是抽象的，它是一种范式，不针对具体的应用场景，它试图以统一的编程接口处理所有的异步操作，以上列举了它的一些特点与优势，但它不仅仅如此。

---
## 2 观察者模式

观察者模式属于对象行为模式之一，也可叫做发布——订阅模式。它定义了一种以对多的依赖关系，让多个观察者（订阅者）同时观察（监听）一个被观察者（主题），当被观察者的状态发生变化时，会通知所有的观察者对象。

与传统的观察者模式不同的是，RxJava中的普通的Observable与Subscriber之间是一对一的订阅关系，也就是说，一般情况下多个Subscriber之间的数据是彼此独立的。而在多播的Observable中是一对多的关系。

### 观察者模式的推模型和拉模型

在实际使用中，数据的传递一般分为两种方式：推模型和拉模型。

- **推模型**：目标对象向观察者推送目标的详细信息，不管观察者是否需要，推送的信息通常是目标对象的全部或者部分数据，相当于是在广播通信
- **拉模型**：目标对象在通知观察者的时候，只传递少量的数据信息，如果观察者需要更加具体的信息，由观察者主动到目标对象中获取，相当于是观察者从目标对象中拉取数据，一般这种模型的实现中，会把目标对象自身通过 update 方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。

---
##  3 一些名词解释

*   **Reactive** 直译为反应性的，有活性的，根据上下文一般翻译为反应式、响应式
*   **Iterable** 可迭代对象，支持以迭代器的形式遍历，许多语言中都存在这个概念
*   **Observable** 可观察对象，在Rx中定义为更强大的Iterable，在观察者模式中是被观察的对象，一旦数据产生或发生变化，会通过某种方式通知观察者或订阅者
*   **Observer** 观察者对象，监听Observable发射的数据并做出响应，Subscriber是它的一个特殊实现
*   **emit** 直译为发射，发布，发出，含义是Observable在数据产生或变化时发送通知给Observer，调用Observer对应的方法
*   **items** 直译为项目，条目，在Rx里是指Observable发射的数据项

与迭代器模式不同的地方在于， 迭代器模式在事件处理上采用的是 “同步/拉式” 的方式，而Observable采用的是 “异步/推式” 的方式 ，对于Subscriber(观察者)而言，这种方式会更加灵活。


RxJava中使用的是推模型，当订阅发生后，Observable主动把具体的数据发射给Subscriber。

---
##  引用

- [RxJava介绍](https://mcxiaoke.gitbooks.io/rxdocs/content/Intro.html)