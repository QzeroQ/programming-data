# 第二章：线程安全性

- 对象的状态：存储在状态变量中的数据，HashMap-->HashMap本身和Map.Entry
- **共享** 意味着可以有对各线程访问，可 **变以** 意味着变量的值可以在生命周期内可以变化

**一个对象是否需要线程安全，取决于是否有多个线程访问它**


## 线程安全性

线程安全性的定义中，最核心的即使**正确性**，而正确性是指：某个类的行为与规范完全一致

## 原子性

- 无状态：不包含任何域，也不包含对其他的类中域的引用，计算过程中临时状态仅存在与线程栈上的局部变量中，并只能有正在执行的线程访问

**无状态的对象一定是线程安全的，**

**原子操作**：不会被其他线程打断的操作，也可以理解为不可分割的一组操作，可以是一个步骤，也可以是多个步骤，但顺序是不被打断的


## 竞态条件

由于不恰当的执行顺序而出现不正确的执行结果，当某个计算的正确结果取决于多个线程的交替执行时，就发生了竞态条件。

最常见的竞态条件：先检查，后执行，比如你的一个操作取决于你观察到的一个结果，当你开始下一步操作时，观察结果已经变得无效了(被另一个线程改变)

```java
        if(a == null){
            a = new A();
        }
        return a;
```

### 加锁机制-synchronized

- 内置锁，每一个Java对象都可以用作一个实现同步的锁，即内置锁或监视器锁。
- 重入：重入意味着获取锁的操作颗粒度是**线程**，而不是 **调用**，如子类覆盖父类的同步方法中，执行一定逻辑，再调用父类的方法。

同步锁可以包含对象的状态，但是如果持有的锁时间太长，也有活跃性与性能的负面影响-所以 **应该尽量将不影响共享状态且执行时间较长的操作从同步代码快中分离出来**

注意：在一组操作中使用了 synchronized 就不要在使用 atomic 变量，使用两种不用的同步机制不仅带来混乱，也不会在性能上带来任何好处。

因此：当执行长时间的计算或者可能无法快速完成的操作(网络请求，I/O)一定不要持有锁

