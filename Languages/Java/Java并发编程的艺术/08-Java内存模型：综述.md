
---
# 1 处理器的内存模型

顺序一致性的内存模型只是一个理论的参考模型，JMM和处理器的内存模型在设计时通常会以顺序一致性内存模型为参考，在设计时，JMM和处理器会对顺序一致性的内存模型做一些放松，如果完全按照顺序一致性的内存模型设计，那么很多处理器和编译器的优化都要被禁止。

一般来说，所有处理器内存模型都允许写-读重排序，因为他们都是用了写缓冲区，写入的是内存缓存区中。

常见的处理器的内存模型都要比JMM的要弱，java编译器在生成字节码时，都会在执行指令序列的适当位置插入内存屏障类限制处理器的重排序，同时因为不同处理器的内存模型也不会相同，所以java编译器在编译时插入的内存屏障也不会相同，JMM屏蔽了不同处理器内存模型的差异性，在不同处理器的平台上为Java程序员保证了一个一致的内存模型。

---
# 2 各内存模型之间的关系

### 单线程内存模型

单线程程序不会出现内存可见性问题，编译器、runtime、处理器都会保证单线程内存的执行结果与顺序一致性模型中的执行结果相同

### 正确同步的多线程程序

正确同步的程序与顺序一致性模型中的执行结果相同，这是JMM关注的重点。

### 未同步/未正确同步的线程程序

JMM为他们保证最小安全性保证：线程执行时读取到的值，要么是之前某个线程写入的值，要么是未初始化的值。

---
# 3 JSR-133对旧内存模型的修补

JSR(Java Specification Requests)-133对JDK内存模型的修补主要有两个：

- 增强了volatile的内存语义
 - 严格volatile变量与普通变量之间的重排序
 - 是volatile的写-读操作与锁的释放-获取具有相同的内存意义
- 增强了final的内存语义
 - 旧的内存模型中多次读取同一个final变量可能读取到不一样的值，JSR-133增加了final变量的重排序规则，为final保证不在构造函数溢出的情况下，final具有初始化安全性。














