# 38-单元测试与UI测试

在完成了应用的开发工作，并解决了代码中的逻辑问题和性能问题之后，接下来就需要测试验收应用的各项功能表现了。移动应用的测试工作量通常很大，这是因为为了验证真实用户的使用体验，测试往往需要跨越多个平台（Android/iOS）及不同的物理设备手动完成。

**自动化测试**：把由人驱动的测试行为改为由机器执行。具体来说就是，通过精心设计的测试用例，由机器按照执行步骤对应用进行自动测试，并输出执行结果，最后根据测试用例定义的规则确定结果是否符合预期。

在自动化测试用例的编写上，Flutter 提供了包括单元测试和 UI 测试的能力。

- 单元测试可以方便地验证单个函数、方法或类的行为
- UI 测试则提供了与 Widget 进行交互的能力，确认其功能是否符合预期

## 1 单元测试

单元测试是指，对软件中的最小可测试单元进行验证的方式，并通过验证结果来确定最小单元的行为是否与预期一致。所谓最小可测试单元，一般来说，就是人为规定的、最小的被测功能模块，比如语句、函数、方法或类。

在 Flutter 中编写单元测试用例，我们可以在 pubspec.yaml 文件中使用 test 包来完成：

```yaml
dev_dependencies:
  test:
```

>test 包的声明需要在 dev_dependencies 下完成，在这个标签下面定义的包只会在开发模式生效。

与 Flutter 应用通过 main 函数定义程序入口相同，Flutter 单元测试用例也是通过 main 函数来定义测试入口的。不过，这两个程序入口的目录位置有些区别：应用程序的入口位于工程中的 lib 目录下，而测试用例的入口位于工程中的 test 目录下。

### 1.1 test 使用示例

在 Flutter 中，测试用例的声明包含定义、执行和验证三个部分：

- 定义和执行决定了被测试对象提供的、需要验证的最小可测单元。
- 验证则需要使用 expect 函数，将最小可测单元的执行结果与预期进行比较。

在 Flutter 中编写一个测试用例，通常包含以下两大步骤：

1. 实现一个包含定义、执行和验证步骤的测试用例；
2. 将其包装在 test 内部，test 是 Flutter 提供的测试用例封装类。

下面演示测试计数器 Counter 的功能：

```dart
class Counter {
  int count = 0;
  void increase() => count++;
  void decrease() => count--;
}
```

测试代码：

```dart
import 'package:test/test.dart';
import 'package:flutter_app/main.dart';

void main() {
  // 第一个用例，判断 Counter 对象调用 increase 方法后是否等于 1
  test('Increase a counter value should be 1', () {
    final counter = Counter();
    counter.increase();
    expect(counter.value, 1);
  });
  // 第二个用例，判断 1+1 是否等于 2
  test('1+1 should be 2', () {
    expect(1+1, 2);
  });
}
```

### 1.2 使用 group 组合多个测试用例

如果有多个测试用例，它们之间是存在关联关系的，我们可以在最外层使用 group 将它们组合在一起。

在下面的例子中，我们定义了计数器递增和计数器递减两个用例，验证递增的结果是否等于 1 的同时判断递减的结果是否等于 -1，并把它们组合在了一起：

```dart
import 'package:test/test.dart';
import 'package:counter_app/counter.dart';
void main() {
  // 组合测试用例，判断 Counter 对象调用 increase 方法后是否等于 1，并且判断 Counter 对象调用 decrease 方法后是否等于 -1
  group('Counter', () {
    test('Increase a counter value should be 1', () {
      final counter = Counter();
      counter.increase();
      expect(counter.value, 1);
    });
 
    test('Decrease a counter value should be -1', () {
      final counter = Counter();
      counter.decrease();
      expect(counter.value, -1);
    });
  });
}
```

### 1.3 使用 mokio 模拟测试场景

在对程序的内部功能进行单元测试时，我们还可能需要从外部依赖（比如 Web 服务）获取需要测试的数据。

比如下面的例子，Todo 对象的初始化就是通过 Web 服务返回的 JSON 实现的。考虑到调用 Web 服务的过程中可能会出错，所以我们还处理了请求码不等于 200 的其他异常情况：

```dart
import 'package:http/http.dart' as http;
 
class Todo {
  final String title;
  Todo({this.title});
  // 工厂类构造方法，将 JSON 转换为对象
  factory Todo.fromJson(Map<String, dynamic> json) {
    return Todo(     
      title: json['title'],
    );
  }
}
 
Future<Todo> fetchTodo(http.Client client) async {
  final response =
  await client.get('https://xxx.com/todos/1');
 
  if (response.statusCode == 200) {
    // 请求成功，解析 JSON
    return Todo.fromJson(json.decode(response.body));
  } else {
    // 请求失败，抛出异常
    throw Exception('Failed to load post');
  }
}
```

考虑到这些外部依赖并不是我们的程序所能控制的，因此很难覆盖所有可能的成功或失败方案。比如，对于一个正常运行的 Web 服务来说，我们基本不可能测试出 fetchTodo 这个接口是如何应对 403 或 502 状态码的。因此，更好的一个办法是，在测试用例中“模拟”这些外部依赖（对应本例即为 http.client），让这些外部依赖可以返回特定结果。

在单元测试用例中模拟外部依赖，我们需要在 pubspec.yaml 文件中使用 mockito 包，以接口实现的方式定义外部依赖的接口：

```yaml
dev_dependencies:
  test:
  mockito:
```

要使用 mockito 包来模拟 fetchTodo 的依赖 http.client，我们首先需要定义一个继承自 Mock（这个类可以模拟任何外部依赖），并以接口定义的方式实现了 http.client 的模拟类；然后，在测试用例的声明中，为其制定任意的接口返回。

在下面的例子中，我们定义了一个模拟类 MockClient，这个类以接口声明的方式获取到了 http.Client 的外部接口。随后，我们就可以使用 when 语句，在其调用 Web 服务时，为其注入相应的数据返回了。在第一个用例中，我们为其注入了 JSON 结果；而在第二个用例中，我们为其注入了一个 403 的异常。

```dart
import 'package:mockito/mockito.dart';
import 'package:http/http.dart' as http;
 
class MockClient extends Mock implements http.Client {}
 
void main() {
  group('fetchTodo', () {
  test('returns a Todo if successful', () async {
    final client = MockClient();
 
    // 使用 Mockito 注入请求成功的 JSON 字段
    when(client.get('https://xxx.com/todos/1'))
        .thenAnswer((_) async => http.Response('{"title": "Test"}', 200));
    // 验证请求结果是否为 Todo 实例
    expect(await fetchTodo(client), isInstanceOf<Todo>());
  });
 
  test('throws an exception if error', () {
    final client = MockClient();
 
    // 使用 Mockito 注入请求失败的 Error
    when(client.get('https://xxx.com/todos/1'))
        .thenAnswer((_) async => http.Response('Forbidden', 403));
    // 验证请求结果是否抛出异常
    expect(fetchTodo(client), throwsException);
  });
});
}
```

运行这段测试用例，可以看到，我们在没有调用真实 Web 服务的情况下，成功模拟出了正常和异常两种结果，同样也是顺利通过验证了。