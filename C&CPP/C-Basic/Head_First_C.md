# Head First C

## 1 C语言入门：进入 C 语言的世界

- C 语言旨在创建空间小、速度快的程序。它比其他大多数语言的抽象层次更低，也就是说用 C 语言写的代码更加接近机器语言。
- 计算机只理解一种语言——机器代码，即一串二进制0、1流。你可以在编译器的帮助下将C代码转化为机器代码。
- 为了写出速度快、空间小、可移植性高的程序，人们常使用 C 语言。绝大多数的操作系统、其他计算机语言和大多数游戏软件都是用C语言写的。

### main 函数

- C 语言是一种很小的语言，如果不使用外部库，它几乎什么也干不了。为了告诉编译器程序要使用哪些外部代码，需要包含（include）相关库的头文件。`stdio.h` 是最常见的头文件，stdio 库中包含了那些能在终端读写数据的代码。
- 所有的 C 代码都在函数中运行。对任何 C程序来讲，最重要的函数是`main()`函数。`main()`函数是程序中所有代码的起点。计算机会从`main()`函数开始运行程序。它的名字很重要：如果没有一个叫`main()`的函数，程序就无法启动。
- `main()`函数的返回类型是int。这是什么意思呢？当计算机在运行程序时，它需要一些方法来判断程序是否运行成功，计算机正是通过检查`main()`函数的返回值来做到这一点。如果让`main()`函数返回0，就表明程序运行成功；如果让它返回其他值，就表示程序在运行时出了问题。
- 在早期的 ANSI C 标准中，`main()`函数可以是void 类型。但是在 C99 标准中 main 函数的返回类型必须是 int。
- 如果想检查程序的退出状态，可以在 Windows 命令提示符中输入：`echo %ErrorLevel%`或在 Linux 或 Mac 终端中输入：`echo $?`
- `main()`这一函数的返回类型是 int，因此必须在函数结束前包含一条 return语句。即使不加，代码也能编译通过，但会收到编译器的警告。支持 C99 标准的编译器会在你忘记的时候插入一条 return 语句。如果你想让编译器遵循 C99 标准，可以使用`-std=99`选项。

### 运行程序

- C 语言是一种编译型语言，也就是说计算机不会直接解释代码，而是需要将给人阅读的源代码转化（或编译）为机器能够理解的机器代码，这样计算机才能够执行。
- 为了编译代码，需要一个叫编译器的程序。GNU 编译器套件（GNU  Compiler  Collection），也叫gcc，是最流行的C编译器之一。gcc 可以在很多操作系统中使用，而且除了C语言，它还可以编译很多其他语言，最重要的是，它是完全免费的。
- 在大部分机器中，可以用下面这个技巧来编译并运行代码：`gcc zork.c -o zork && ./zork`(在 Windows 中，应该输入 zork 而不是 ./zork)，这条命令只有在编译成功的情况下才会运行新程序，一旦编译过程中出了问题，它就会跳过运行程序这一步，仅仅在屏幕上显示错误消息。
- 为什么我在 Linux 和 Mac 中运行程序时必须在程序前加上`./`？因为在类 Unix 操作系统中，运行程序必须指定程序所在的目录，除非程序的目录已经列在了 PATH 环境变量中。

### C语言字符串

- C 语言不支持现成的字符串
- C 语言比其他大多数语言的抽象层次更低，因此它不提供字符串，而是用了相似的东西来代替：以字符为元素的数组。
- 字符串只是字符数组，当C语言看到一个这样的字符串时：`s = "Shatner"`，会把它当做一个数组读取，而这个数组是由一个个独立的字符组成的：`s = {'S', 'h', 'a', 't', 'n', 'e', 'r'}`。
- **哨兵字符**：C语言比大多数语言更低层，它无法确切地知道数组有多长，如果 C 语言想在屏幕上显示字符串，它就需要知道什么时候会到达字符数组的尾部，为此C语言加入了哨兵字符。哨兵字符是一个出现在字符串末尾的附加字符，它的值为 `\0`。每当计算机需要读取字符串的内容时，它会逐一扫描字符数组中的所有元素，直到碰到`\0`。
- `s = "Shatner"` 存储器中实际保存的是：`{'S', 'h', 'a', 't', 'n', 'e', 'r', '\0'}`。
- 为什么要设立哨兵字符？难道计算机就不知道字符串的长度吗？通常不知道。记录数组的长度不是C语言的强项，虽然编译器有时可以通过分析代码计算出数组的长度，但一般情况下，C 语言希望你来记录数组的长度，字符串其实就是个数组。
- 通常应该用双引号来定义字符串。用双引号定义的字符串叫字符串字面值（string  literal），比起字符数组，它输入起来也更方便。
- 字符串字面值和字符数组有没有区别？只有一个区别：字符串字面值是常量。也就是说这些字符一旦创建完毕，就不能再修改它们。如果修改它们就会遇到错误，具体什么错误取决于编译器，gcc 通常会显示总线错误（bus error）。
- **总线错误**：C语言采取不同的方式在存储器中保存字符串字面值。总线错误意味着程序无法更新那一块存储器空间。

### switch

- 我能在 switch 语句中检查字符串吗？不能用 switch 语句检查字符串或任何形式的数组，switch 语句只能检查值。

## 2 存储器和指针

如果真的想玩转C语言，就需要理解C语言如何操纵存储器。

### 指针

- 指针是理解C语言最基本的要素之一。那么什么是指针？指针就是存储器中某条数据的地址。
- 在C语言中使用指针有以下几个原因：
  - 在函数调用时，可以只传递一个指针，而不用传递整份数据。
  - 让两段代码处理同一条数据，而不是处理两份独立的副本。
- 指针就做了两件事：避免副本和共享数据。

### 深入挖掘存储器

- 每当声明一个变量，计算机都会在存储器中某个地方为它创建空间。如果在函数（例如main()函数）中声明变量，计算机会把它保存在一个叫栈（Stack）的存储器区段中。
- 在函数以外的地方声明变量，计算机则会把它保存在存储器的全局量段（Globals）。
- 变量的地址告诉你去哪里找存储器中的变量，这就是为什么地址有时也叫指针，因为它指向了存储器中的变量。
- 为什么局部变量保存在栈里，而全局变量保存在其他地方？局部变量和全局变量的用法不同。你永远只能得到一份全局变量，但如果写了一个调用自己的函数，就会得到同一个局部变量的很多个实例。
- 指针是真实的地址单元，还是某种形式的引用？它们是进程存储器中真实编号的地址。
- 为什么存储器是进程的？计算机会为每个进程分配一个简版存储器，看起来就像是一长串字节。实际的存储器复杂多了，但细节对进程隐藏了起来，这样操作系统就可以在存储器中移动进程，或释放并重新加载到其他位置。（MMU 负责虚拟内存和实际内存地址映射）
- 物理存储器：物理存储器的结构十分复杂，计算机通常会将存储器地址分组映射到存储芯片的不同的存储体（memory bank）。对大部分程序来说，不需要关心机器组织存储器的细节。
- 引用与指针：人们有时会把指针叫做“引用”，因为它引用了存储器中的某个地址单元。但C++程序员通常用“引用”表示C++中一个稍有不同的概念。

### 指针与数组

- 当你创建了一个数组，数组变量就可以当作指针使用，它指向数组在存储器中的起始地址。
- 对于 `char quote[] = "Cookies make you fat";`，计算机会为字符串的每一个字符以及结束字符`\0`在栈上分配空间，并把首字符的地址和 quote 变量关联起来，代码中只要出现这个 quote 变量，计算机就会把它替换成字符串首字符的地址。其实，数组变量就好比一个指针。
- 给函数参数组类型参数时，其实传给函数的是指针。即把数组变量传给指针，会发生退化。
- sizeof(指针)在 32 位操作系统中返回 4，在 64 位操作系统中返回 8。在 32 位操作系统中，存储器地址以32位数字的形式保存，所以它叫 32 位操作系统。32 位==4 字节，所以 64 位操作系统要用 8 个字节来保存地址。
- 运算符：编译器会把运算符编译为一串指令；而当程序调用函数时，会跳到一段独立的代码中执行。
- 程序是在编译期间计算 sizeof 的，编译器可以在编译时确定存储空间的大小。
- 数组变量可以用作指针，这个指针指向数组的第一个元素，也就是说除了方括号表示法，还可以用`*`运算符读取数组的第一个元素。
- 索引的本质是指针算术运算，所以数组从 0 开始。假设 drinks 是一个数组，则表达式 `drinks[i]` 和 `*(drinks + i)` 是等价的。

### 数组变量与指针不完全相同

```c
char s[] = "How big is it?";
char *t = s;
```

- sizeof（数组）是数组的大小。
- 指针变量是一个用来保存存储器地址的变量，那数组变量呢？如果对数组变量使用&运算符，结果是数组变量本身。
- 当程序员写下`&s`时，表示“数组s的地址是？”，数组s的地址就是 `s`；但如果他写的是`&t`，则表示“变量t的地址是？”。
- **数组变量不能指向其他地方**：当创建指针变量时，计算机会为它分配4或8字节的存储空间。但如果创建的是数组呢？计算机会为数组分配存储空间，但不会为数组变量分配任何空间，编译器仅在出现它的地方把它替换成数组的起始地址。但是由于计算机没有为数组变量分配空间，也就不能把它指向其他地方。`s = t;`会导致编译错误。
- 为什么数组变量不保存在存储器中？既然它存在，就应该在某个地方，不是吗？程序在编译期间，会把所有对数组变量的引用替换成数组的地址。也就是说在最后的可执行文件中，数组变量并不存在。既然数组变量从来不需要指向其他地方，有和没有其实都一样。

### 指针有类型

为什么指针有类型？指针变量具有类型，这样就能调整指针算术运算。

- 如果对char指针加1，指针会指向存储器中下一个地址，那是因为char就占1字节。
- 如果是int指针呢？int通常占4字节，如果对int指针加1，编译后的代码就会对存储器地址加4。
- C语言什么时候对指针算术运算进行调整？在编译器生成可执行文件时，编译器会根据变量的类型，用变量的大小乘以指针的增量或减量。假如编译器看到你对一个指向int数组的指针加2，就会用2乘以4（int的长度），然后对地址加8。

```c
int doses[] = {1, 3, 2, 1000};
//doses[3] == *(doses + 3) == *(3 + doses) == 3[doses]
printf("服用 %i 毫克的药", 3[doses]);
```

### 用指针输入数据：scanf 和 fgets

```c
//scanf
char name[40];
printf("Enter your name: ");
scanf("%39s", name);

//scanf
char first_name[20];
char last_name[20];
printf("Enter first and last name: ");
scanf("%19s %19s", first_name, last_name);
printf("First: %s Last:%s\n", first_name, last_name);
```

- scanf()其实表示“scan formatted”，它用来扫描带格式的输入。
- **`scanf()`可能导致溢出**：如果忘了限制`scanf()`读取字符串的长度，用户就可以输入远远超出程序空间的数据，多余的数据会写到计算机还没有分配好的存储器中。如果运气好，数据不但能保存，而且不会有任何问题。但缓冲区溢出很有可能会导致程序出错，这种情况通常被称为段错误 或 abort trap，不管出现什么错误消息，程序都会崩溃。

```c
char food[5];
printf("Enter favorite food: ");
fgets(food, sizeof(food), stdin);
```

- 调用`fgets()`时不可能一不小心忘记设置长度，因为它就出现在了函数的签名中，所以不得不加这个参数。另外，注意`fgets()`缓冲区大小把`\0`字符也算了进去，所以不必像`scanf()`那样把长度减1。
- `fgets()`函数其实是从一个更古老的函数演变而来的，它叫`gets()`。尽管我们说`fgets()`比`scanf()`更加安全，但它的祖先`gets()`才是最危险的。为什么？因为`gets()`函数没有任何限制。

```c
char dangerous[10];
gets(dangerous);
```

scanf 和 fgets 对比：

- 限制用户输入的字符数吗？
  - `scanf()` 只要记得在格式串中加入长度，`scanf()` 就能限制用户输入数据的长度。
  - `fgets()` 强行限制用户输入字符串的长度，可谓无懈可击。
- 能输入多个字段吗？
  - `scanf()`不但允许输入多个字段，而且允许输入结构化数据，可以指定两个字段之间以什么字符分割。
  - `fgets()`只允许向缓冲区中输入一个字符串，而且只能是字符串，不能是其他数据类型，只能有一个缓冲区。
- 用户能输入带空格的字符串吗？
  - 当`scanf()`用`%s`读取字符串时，遇到空格就会停止。如果想要输入多个单词，需要多次调用`scanf()`，或使用一些复杂的正则表达式技巧。
  - 无论何时，`fgets()`都能读取整个字符串。

### 字符串字面值不能更新

这是由C语言使用存储器的方式决定的

```c
//不能用这个变量修改这个字符串。
char *cards = "JQK";
// 但如果你用字符串字面值创建一个数组，就可以修改了：
char cards[] = "JQK";
```

对于存储器中的`char *cards=“JQK”;`：

- 计算机加载字符串字面值：当计算机把程序载入存储器时，会把所有常数值（如字符串常量“JQK”）放到常量存储区，这部分存储器是只读的。
- 程序在栈上创建cards变量：栈是存储器中计算机用来保存局部变量的部分，局部变量也就是位于函数内部的变量，cards变量就在这个地方。
- cards变量设为“JQK”的地址：cards变量将会保存字符串字面值“JQK”的地址。为了防止修改，字符串字面值通常保存在只读存储器中。
- 计算机试图修改字符串：程序试图修改cards变量指向的字符串中的内容时就会失败，因为字符串是只读的。
- 如果想修改字符串，就复制它。

对于存储器中的`char cards[]=“JQK”;`：

- 计算机载入字符串字面值：和刚刚一样，当计算机把程序载入存储器时，会把常量值（如字符串“JQK”）保存到只读存储器。
- 程序在栈上新建了一个数组：我们声明了数组，所以程序会创建一个足够大的数组来保存字符串 “JQK”，在这个例子中 4 个字符足矣。
- 程序初始化数组：除了为数组分配空间，程序还会把字符串字面值 “JQK” 的内容复制到栈上。

`const char *`：

- 可以将 char 指针声明成为`const char  *`，以防代码用它修改字符串。
- 其实加不加 const，字符串字面值都是只读的，const 修饰符表示，一旦你试图用 const 修饰过的变量去修改数组，编译器就会报错。

### 声明与定义

声明是一段代码，它声称某样东西（变量或函数）存在。定义说明它是什么东西。如果在声明了变量的同时将其设为某个值（例如int x = 4;），这段代码既是声明又是定义。

### 存储器区域

- 栈：这是存储器用来保存局部变量的部分。每当调用函数，函数的所有局部变量都在栈上创建。它之所以叫栈是因为它看起来就像堆积而成的栈板：当进入函数时，变量会放到栈顶；离开函数时，把变量从栈顶拿走。奇怪的是，栈做起事来颠三倒四，它从存储器的顶部开始，向下增长。
- 堆：堆用于动态存储：程序在运行时创建一些数据，然后使用很长一段时间。
- 全局量：全局量位于所有函数之外，并对所有函数可见。程序一开始运行时就会创建全局量。
- 常量：常量也在程序一开始运行时创建，但它们保存在只读存储器中。常量是一些在程序中要用到的不变量。
- 代码：很多操作系统都把代码放在存储器地址的低位。代码段也是只读的，它是存储器中用来加载机器代码的部分。

### string.h

- `string.h`是C标准库的一员，它负责处理字符串。如果想要连接、比较或复制字符串，`string.h` 中的函数就可以派上用场了。
- 如果使用到 string.h 中的函数，但忘了包含 string.h 这样的头文件会怎么样？对于某些头文件来说，编译器会给出一个警告，但最后还是会包含它们；但对另一些来讲，编译器会直接提示编译错误。

## 3 创建小工具

有一种小工具叫过滤器（filter），它逐行读取数据，对数据进行处理，再把数据写到某个地方。如果你的计算机是Unix，或你在Windows上安装了Cygwin，就已经拥有很多过滤器工具了。head：显示文件前几行的内容。tail：显示文件最后几行的内容。sed：流编辑器（stream editor），用来搜索和替换文本。

### 标准输入输出和重定向

- 操作系统控制数据如何进出标准输入、标准输出。如果在命令提示符或终端运行程序，操作系统会把所有键盘输入都发送到标准输入；默认情况下，如果操作系统从标准输出中读到数据，就发送到显示器。
- `scanf()`和`printf()`函数并不知道数据从哪里来，也不知道数据要到哪里去，它们也不关心这点，它们只管从标准输入读数据，向标准输出写数据。
- 操作系统为什么要使用标准输入、标准输出与程序交互呢？有一个很好的原因：因为这么一来，就可以重定向标准输入、标准输出，让程序从键盘以外的地方读数据、往显示器以外的地方写数据，例如文件。
- 用 `<` 重定向标准输入，用 `>` 重定向标准输出。