# vector

C++ 标准库类型 vector 表示对象集合，内部所有对象的类型一致，通过索引访问对象。

## 1 使用 vector

使用 vector 之前，必须包含相应的头文件：

```cpp
#include <vector>
using std::vector;
```

vector 是一个类模板（class template）。使用模板可以编写一个类定义或函数定义，而用于多个不同的数据类型。声明从类模板产生的某种类型的对象，需要提供附加信息，信息的种类取决于模板，对于 vector 必须说明 vector 保存何种对象的类型，通过将类型放在类型放在类模板名称后面的尖括号中来指定类型：

```cpp
#include <vector>
using std::vector;

vector<int> ints;
```

## 2 vector的各种初始化形式

函数 | 说明
---|---
`vector<T> v1;` | vector 保存类型为 T 对象。 默认构造函数 v1 为空。
`vector<T> v2(v1);` | v2 是 v1 的一个副本。
`vector<T> v3(n, i);` | v3 包含 n 个值为 i 的元素。
`vector<T> v4(n);` | v4 含有值初始化的元素的 n 个副本。

使用 `vector<T> v4(n);` 是，元素的初始化规则：

- 情况1：如果没有指定元素的初始化式，那么标准库将自行提供一个元素初始值进行值初始化（value initializationd）。这个由库生成的初始值将用来初始化容器中的每个元素，具体值为何，取决于存储在 vector 中元素的数据类型。比如 int 将初始化为 0，string 将初始化为空字符串。
- 情况2：对于一些有自定义构造函数但没有默认构造函数的类，在初始化这种类型的 vector 对象时，程序员就不能仅提供元素个数，还需要提供元素初始值。
- 情况3：元素类型可能是没有定义任何构造函数的类类型。这种情况下，标准库仍产生一个带初始值的对象，这个对象的每个成员进行了值初始化。

## 3 vector的常用操作

函数 | 说明
---|---
`v.empty()` | 如果 v 为空，则返回 true，否则返回 false。
`v.size()` | 返回 v 中元素的个数。
`v.push_back(t)` | 在 v 的末尾增加一个值为 t 的元素。
`v[n]` | 返回 v 中位置为 n 的元素。
`v1 = v2` | 把 v1 的元素替换为 v2 中元素的副本。
`v1 == v2` | 如果 v1 与 v2 相等，则返回 true。
`!=, <, <=, | >, and >=` | 保持这些操作符惯有的含义

- 不能通过下标添加元素，vector 对象的下标可用于访问已存在的元素，但是不能用于添加元素。
- 关于下标必需明确，只能对确知已存在的元素执行下标操作，如果下标越界，可能会得到一个未知的值，所谓缓冲区溢出就是这类错误。
- `=` 对比的 vector 的内容

```cpp
vector<int> vector1(1, 10);
vector<int> vector2(1, 10);
cout << "vector1 == vector2 = " << (vector1 == vector2) << endl;//true
cout << "vector1 === vector2 = " << (&vector1 == &vector2) << endl;//false

```

## 3 vector能高效的增长

C++标准要求，vector能在运行时高效的增长，因此在定义vector对象时设定其大小就没有必要了，事实上这么做，可能性能更差，**只有一种情况例外，就是所有元素的值都一样**。否则有更有效的方法是先定义一个空的vector，然后在运行时添加元素。

## 4 安全的泛型编程

对于 for 循环遍历 vector，有以下建议：

```cpp
 reset the elements in the vector to zero
 for (vector<int>::size_type ix = 0; ix != ivec.size(); ++ix)
    ivec[ix] = 0;
```

1. 对于遍历结束的条件判断，推荐使用 `!=` 而不是 `<`。
2. 不在 for 循环之前就调用 size 成员函数并保存其返回的值，而是在 for 语句头中调用 size 成员函数：在 C++ 中，有些数据结构（如 vector）可以动态增长。上例中循环仅需要读取元素，而不需要增加新的元素。但是，循环可以容易地增加新元素，如果确实增加了新元素的话，那么测试已保存的 size 值作为循环的结束条件就会有问题，因为没有将新加入的元素计算在内。所以我们倾向于在每次循环中测试 size 的当前值，而不是在进入循环前，存储 size 值的副本。在标准库中，像 size 这样的小库函数几乎都定义为内联函数，所以每次循环过程中调用它的运行时代价是比较小的。
