# 变量与数据类型

---
## 1 基本内置类型

理解变量：变量是程序可操作的存储区的名称。C++中每个变量都有指定的类型，类型决定了变量存储的大小和布局。

C++定义了一套包括算术(arithmetic)类型和空类型(void)在内的基本数据类型。

- 算术类型包括：整数、布尔类型、字符、和浮点类型。
- 空类型不对应任何具体的值，仅用于一些特殊场合。

**注意**：不要混用有符号类型的数据和无符号类型的数据

```cpp
    int va = -1;
    unsigned int vb = 1;
    int vc = va * vb;//此时va会自动转为为无符号类型的整数
```

### 1.1 整形

整型表示 整数 、 字符 和 布尔值 的算术类型合称为整型。C++ 使用八进制或者十六进制的字面量的方式与 Java 类似，0 开头表示八进制，0x 表示 16 进制。

| 整型           | 字节 | 取值范围                        | 占位 |
| ------------- | ---- | ------------------------------- | ---- |
| int            | 4    | -2,147,483,648 到 2,147,483,647 | %d   |
| unsigned int   | 4    | 0 到 4,294,967,295              | %u   |
| short          | 2    | -32,768 到 32,767               | %hd  |
| unsigned short | 2    | 0 到 65,535                     | %hu  |
| long           | 4    | -2,147,483,648 到 2,147,483,647 | %ld  |
| unsigned long  | 4    | 0 到 4,294,967,295              | %lu  |
| char           | 1    | -128 到 127                     | %c   |
| unsigned char  | 1    | 0 到 255                        | %c   |

>long int 其实就是长整型，可以省去int，在标准中,规定 int 至少和 short 一样长，long 至少和 int 一样长。long 和 int 在早期 16 位电脑时候， int 2 占字节，long 4 占字节，而计算机发展到现在，一般 32、64 下，long 和 int一样。和 java 类比的话，java 的 long 就是 long long 占 8字节。

#### 字符类型

有 `char` 和 `wchar_t` 两种。

- `char` 类型保证了有足够的空间，能够存储机器基本字符集中任何字符相应的数值，因此，**char 类型通常是单个机器字节**。
- `wchar_t` 类型用于扩展字符集，比如汉字和日语，这些字符集中的一些字符不能用单个 `char` 表示。
- char 的符号：char 在默认情况下既不是没有符号，也不是有符号。是否有符号由 C++ 实现决定，这样编译器开发人员可以最大限度地将这种类型与硬件属性匹配起来。如果char 有某种特定的行为对您来说非常重要，则可以显式地将类型设置为 signed char 或 unsigned char，如果将 char 用作数值类型，则 unsigned char 和signed char之间的差异将非常重要。unsigned char类型的表示范围通常为0～255，而signed char的表示范围为−128到127。

**wchar_t 详情**：

- 底层类型：wchar_t类型是一种整数类型，它有足够的空间，可以表示系统使用的最大扩展字符集。这种类型与另一种整型（底层（underlying）类型）的长度和符号属性相同。对底层类型的选择取决于实现，因此在一个系统中，它可能是unsigned short，而在另一个系统中，则可能是int。
- 输入输出：cin和cout将输入和输出看作是char流，因此不适于用来处理wchar_t类型。iostream头文件的最新版本提供了作用相似的工具—wcin和wcout，可用于处理wchar_t流。另外，可以通过加上前缀L来指示宽字符常量和宽字符串。

```cpp
//定义一个宽字符常量
wchar_t bob = L'你';
//输出一个宽字符串
wcout << L"tall" << endl;
```

**C++11新增的类型：`char16_t和char32_t`**：

1. 在计算机系统上进行字符和字符串编码时，仅使用 Unicode 码点并不够。进行字符串编码时，如果有特定长度和符号特征的类型，将很有帮助，而类型 wchar_t 的长度和符号特征随编译器实现。
2. C++11 新增了类型 char16_t 和 char32_t，其中前者是无符号的，长 16 位，而后者也是无符号的，但长 32 位。
3. C++11 使用前缀 u 表示 char16_t 字符常量和字符串常量，如 u‘C’ 和 u“be good”。
4. C++11 使用前缀 U 表示 char32_t 字符常量和字符串常量，如 U‘C’ 和 U“be good”。
5. 与 wchar_t 一样，char16_t 和 char32_t 也都有底层类型—一种内置的整型，但底层类型可能随系统而已。

>为什么要引入`char16_t和char32_t`，char16_t和char32_t 被创建为在所有平台上以统一的方式处理UTF 16／32。最初，有cc，但是它是在Unicode是新的时候创建的，它的字节大小从来没有标准化，直到今天。在某些平台上，wchar_t是16位（utf-16），而在其他平台上则是32位（utf-32）。多年来，当跨平台交换Unicode数据时，这导致了大量的互操作性问题。wchar_t和char16_t最终被引入，在所有平台上分别具有标准化的大小（16位和32位）和语义。引用<http://www.ojit.com/article/1198225>

#### 布尔值

`bool` 类型表示真值 true 和 false。可以将算术类型的任何值赋给 bool 对象。0 值算术类型代表 false， 任何非 0 的值 都代表 true。

#### 溢出

- unsigned 类型：unsigned类型的数总是正值或0，负数总是超出其取值范围。并遵守 算数模` 2的n次方`定律 ，其中n是该类型占用的位数。例如，如果试图将 336 存储到 8 位的`unsigned char` 中，则实际赋值为80，因为 80 是 336 对 256 求模后的值。
- signed 类型：由编译器决定实际赋的值。在实际操作中，很多的编译器处理 `signed` 类型的方式和 `unsigned` 类型类似。也就是说，赋值时是取该值对该类型取值数目求模后的值。然而我们不能保证编译器都会这样处理 signed 类型。

### 1.2 浮点型

类型 `float、 double 和 long double` 分别表示单精度浮点数、双精度浮点数和扩展精度浮点数。

- float 类型用一个字(32 位)来表示，
- double 类型用两个字(64 位)来表示，
- long double 类型用三个或四个字(96 或 128 位)来表示。

类型的取值范围决定了浮点数所含的有效数字位数。 **float 型只能保证 6 位有效数字 ，而 double 型至少可以保证 10 位有效数字**。

| 浮点型      | 字节 | 精度     | 占位 |
| ----------- | ---- | -------- | ---- |
| float       | 4    | 6位小数  | %f   |
| double      | 8    | 15位小数 | %lf  |
| long double | 8    | 19位小数 | %Lf  |

---
## 2 复合类型

复合类型是指基于其他基本类型定义的类型。比如**引用和指针**。

### 2.1 引用

一般使用的术语 **引用** 指的是左值引用。引用为对象起了另外一个名字，引用类型引用另外一种类型。通过将声明符写成`&d`(每个引用都必须以 & 开头)来定义引用类型，其中d是声明的变量名。定义引用类型时，引用类型必需被初始化。引用并非对象，它只是为一个已经存在的对象取另一个名字。而且 **引用类型一经被初始化，就一直和它的初始值对象绑定在一起。**

### 2.2 指针

指针是指向另一种类型的复合类型，与引用不同的是：

- 指针本身是一个对象，允许对指针进行赋值和拷贝。
- 指针无需在定义时初始化，引用必须在创建时被初始化。
- 不存在空引用。引用必须连接到一块合法的内存。但存在空指针。
- 一旦引用被初始化为一个对象，就不能被指向到另一个对象。指针可以在任何时候指向到另一个对象。

指针值有以下四种状态：

- 指向一个对象
- 指向临近对象所占空间的下一个位置
- 空指针，没有指向任何对象
- 无效指针

NULL是一个预处理变量，用来给指针赋值，定义在`cstdlib`中，它的值是`0`。`void*`指针是一种特殊的指针类型，可用于存放任意对象的地址。

### 2.3 const 限定符

const 用于定义常量，默认状态下，const 仅在文件内有效。如果想在多个文件内共享 const 变量，必需在 const 变量的定义之前添加 `extern` 关键字。在其文件中使用`extern`声明。一般将常量名称的首字母大写，以提醒该变量是个常量。

```c
//file1.cpp
extern const int size = 100;

//file2.cpp
extern const int size//与file1的size是同一个
```

#### const 的引用

可以把引用绑定到 const 对象上，称之为对常量的引用。

```c
const int c1 = 1024;
cosnt int &r1 = c1;

//不应使用非 const引用引用 const 变量
onst int ival = 1024;
const int &refVal = ival;//允许
int &ref2 = ival;//不允许
```

惯用术语：

- “const 引用”的意思是“指向 const 对象的引用”。
- “非 const 引用”表示指向非 const 类型的引用。

#### const与指针

- 指向常量的指针：`const int *p = &i`，不能通过 p 给 i 赋值。
- const指针：`int *const p = &1`，不能修改 p 指向别的 int 变量。

>`const int *p = &i`中离p最近的是*，表示它是一个指针，剩余部分const int说明它指向的是int常量。<br/>
>`int *const p = &1`中离p最近的是const，所以p是一个常量，然后剩余部分觉得它的类型，int *表示它是一个int指针。

### 2.4  constexpr 常量表达式（C++11）

常量表达式是指值不会改变且在编译阶段就能计算结果的表达式。

```c
const int a = 32;//a是一个常量表达式
const int b = a+1;//b是一个常量表达式
int c = 32;//c不是一个常量表达式，它没有被const修饰
const int szie = get_size();//size不是一个常量表达式，其值在运行时才能确认。
```

C++11新标准规定，允许将变量声明为 constexpr 类型，以便编译器来校验变量的值是否为一个常量表达式。声明 constexpr 的变量一定是常量，且必需使用常量表达式。

#### 指针和 constexpr

在 constexpr 声明中如果使用了指针，限定符 constexpr 仅对指针有效，与指针所指的对象无关。

```c
    const int *pA = nullPtr;//pA是一个指向普通整型常量的指针，即无法修改指针的指向
    constexpr int *pB = nullPtr;//pB是一个指向普通整型的常量指针，即无法修改指针的指向
```

### 2.5 处理类型

#### 类型别名

使用`typedef`可以给数据类型起新的名字。typedef 通常被用于以下三种目的：

- 为了隐藏特定类型的实现，强调使用类型的目的。
- 简化复杂的类型定义，使其更易理解。
- 允许一种类型用于多个目的，同时使得每次使用该类型的目的明确。

#### auto类型说明符

C++11新标准引入了`auto`类型说明符，用它可以让编译器替开发者分析表达式所属的类型。

#### decltype类型指示符（C++11）

如果系统从表达式推断出要定义的类型，但是又不希望使用该表达式的结果作为初始化值，则可以使用 C++11 引入的第二种类型说明符`decltype`。

```c
decltype(f()) value = x;//value的类型就是f的返回值类型。
```

示例：

```cpp
const int ci = 0, &cj = ci;
decltype(ci) x = 0;//x的类型是const int
decltype(cj) y = x;//y的类型是const int&，y绑定到了x
//decltype(cj) z; //decltype(cj)是引用类型，必需初始化

int i = 4, h = 44, *p = &i, &r = i;
decltype(r + 0) b;//加法的结果是一个int，所以b的类型是一个int类型
//(*p)是引用类型int&，必需被初始化。如果表达式的内容是解引用操作，则decltype将得到引用类型，
// 正如我们熟悉的那样，解引用指针可以得到指针所指的对象，而且还能给这个对象赋值，因此decltype(*p)的结果就是int&，而非int
decltype(*p) c = i;
decltype(i) j;
// decltype((i))形式的结果永远是引用，而 decltype(i)只有当i本身是一个引用的时候才是引用。
decltype((i)) rB = h;
```

#### C++ 中的变量声明

变量声明向编译器保证变量以给定的类型和名称存在，这样编译器在不需要知道变量完整细节的情况下也能继续进一步的编译。变量声明只在编译时有它的意义，在程序链接接时编译器需要实际的变量声明。

### 2.6 自定义数据结构

C/C++ 数组允许定义可存储相同类型数据项的变量，但是结构是 C++ 中另一种用户自定义的可用的数据类型，它允许你存储不同类型的数据项。

从最基本的层面理解，数据结构就是把一组相关的数据元素组织起来然后使用它们的成员和方法。C++允许用户以类的形式自定义数据类型。

- 可以使用struct关键字定义数据结构。
- C++11新的规定，**可以为类内数据成员定义初始化值**。
- 类(数据机构)的定义应该放在头文件中。每个头文件都应该使用预编译指定防止重复引用。

类与结构体在C++中只有两点区别，除此这外无任何区别：

- class中默认的成员访问权限是private的，而struct中则是public的。　　
- 从class继承默认是private继承，而从struct继承默认是public继承。

---
## 3 初始化规则简介

## 初始化

变量定义指定了变量的类型和标识符，也可以为对象提供初始值。定义时指定了初始值的对象被称为是已初始化的。C++ 支持两种初始化变量的形式：

- 复制初始化：复制初始化语法用等号（=）。
- 直接初始化：直接初始化则是把初始化式放在括号中。

```cpp
int ival(1024);     // direct-initialization
int ival = 1024;    // copy-initialization
```

在 C++ 中理解“**初始化不是赋值**”是必要的。初始化指创建变量并给它赋初始值，而赋值则是擦除对象的当前值并用新值代替。

- 务必清楚使用 `=` 来初始化变量不是直接初始化，而是赋值操作。
- 直接初始化语法更灵活且效率更高。

基本类型的初始化与类类型初始化：

- 初始化内置类型的对象只有一种方法：提供一个值，并且把这个值复制到新定义的对象中。对内置类型来说，复制初始化和直接初始化几乎没有差别。
- 对类类型的对象来说，有些初始化仅能用直接初始化完成。要想理解其中缘由，需要初步了解类是如何控制初始化的。

### 内置类型变量的初始化

定义基本数据类型变量（单个值、数组）的同时可以指定初始值，如果未指定 C++ 会去执行默认初始化(default-initialization)。 那么什么是”默认初始化”呢？

内置类型变量是否自动初始化取决于变量定义的位置。

- 在函数体外定义的变量都初始化成 0，
- 在函数体里定义的内置类型变量不进行自动初始化。
- 除了用作赋值操作符的左操作数，未初始化变量用作任何其他用途都是没有定义的。未初始化变量引起的错误难于发现。

总结：

- 栈中的变量（函数体中的自动变量）和堆中的变量（动态内存）会保有不确定的值。
- 全局变量和静态变量（包括局部静态变量）会初始化为零。

函数体中的变量定义是这样的规则：

```cpp
int i;                    // 不确定值
int i = int();            // 0
int *p = new int;         // 不确定值
int *p = new int();       // 0
```

### 类类型变量的初始化

每个类都定义了该类型的对象可以怎样初始化。定义如何进行初始化的成员函数称为构造函数，类通过定义一个或多个构造函数来控制类对象的初始化。

以 string 类为例：string 类定义了几个构造函数，使得我们可以用不同的方式初始化 string 对象。

```cpp
// 初始化 string 对象的一种方式是作为字符串字面值的副本：
std::string titleA = "C++ Primer, 4th Ed.";
std::string titleB("C++ Primer, 4th Ed.");

// 也可以通过一个计数器和一个字符初始化 string 对象。这样创建的对象包含重复多次的指定字符，重复次数由计数器指定：
std::string all_nines(10, '9');

//也可以创建一个空字符串
std:string empty;
```

上面 string 类提供了两个构造函数

- 其中一个允许我们通过字符串字面值初始化 string 对象。
- 另外一个允许我们通过字符和计数器初始化 string 对象。

**默认构造函数**：如果定义某个类的变量时没有提供初始化式，这个类也可以定义初始化时的操作。它是通过定义一个特殊的构造函数即默认构造函数来实现的。这个构造函数之所以被称作默认构造函数，是因为它是“默认”运行的。如果没有提供初始化式，那么就会使用默认构造函数。不管变量在哪里定义，默认构造函数都会被使用。

- 大多数类都提供了默认构造函数。如果类具有默认构造函数，那么就可以在定义该类的变量时不用显式地初始化变量。比如 string。
- 有些类类型没有默认构造函数。对于这些类型来说，每个定义都必须提供显式的初始化式。没有初始值是根本不可能定义这种类型的变量的。
