# 面向对象（Object-oriented programming，OOP）

面向对象编程基于三个基本概念：数据抽象、继承和动态绑定。

- **数据抽象**：定义类其实就是对数据的抽象。
- **继承**：继承集成允许从一个类派生出另一个类，派生类继承基类暴露的成员。
- **动态绑定**：有了动态绑定，编译器能够在运行时决定是使用基类中定义的函数还是派生类中定义的函数。

---
## 1 定义基类和派生类

### 1.1 继承

继承允许从一个类派生出另一个类，派生类继承基类暴露的成员：

- 被继承者称为基类（base class）
- 继承者成为派生类（derived class）

继承代表了 **is a** 关系，继承的语法如下：

```cpp
// 访问修饰符 access-specifier 是 public、protected 或 private 其中的一个 base-class 是之前定义过的某个类的名称。
// 如果未使用访问修饰符 access-specifier，则默认为 private。
class derived-class: access-specifier base-class
```

### 1.2 派生类

- **内存分布**：内存上，C++ 语言不要求编译器将对象的基类部分和派生部分和派生部分连续排列。
- **派生类的声明**：如果需要声明（但并不实现）一个派生类，则声明包含类名但不包含派生列表。

```cpp
//错误，向前声明不能声明派生列表
class DerivedClass : public BaseClass;

//正确的向前生命
class DerivedClass;
class BaseClass;
```

### 1.3 继承与访问控制权

派生类可以访问基类中所有的非私有成员。因此基类成员如果不想被派生类的成员函数访问，则应在基类中声明为 `private`。

一个派生类继承了所有的基类方法，但下列情况除外：

- 基类的构造函数、析构函数和拷贝构造函数。
- 基类的重载运算符。
- 基类的友元函数。

### 1.4 继承类型

当一个类派生自基类，该基类可以被继承为 `public`、`protected` 或 `private` 几种类型。继承类型是通过访问修饰符来指定的。

- 公有继承（`public`）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。
- 保护继承（`protected`）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。
- 私有继承（`private`）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。

**接口继承与实现继承**:

- 接口继承：public 派生类继承基类的接口，它具有与基类相同的接口。设计良好的类层次中，public 派生类的对象可以用在任何需要基类对象的地方。
- 实现继承：使用 private 或 protected 派生的类不继承基类的接口，相反，这些派生通常被称为实现继承。派生类在实现中使用被继承但继承基类的部分并未成为其接口的一部分。

**去除个别成员**：

使用实现继承时，派生类可以恢复继承成员的访问级别，但不能使访问级别比基类中原来指定的更严格或更宽松，可以在派生类的 public 部分增加一个 using 声明 `uing BaseClass::filed_name;`。

### 1.5 友元关系与继承

友元关系不能继承。基类的友元对派生类的成员没有特殊访问权限。如果基类被授予友元关系，则只有基类具有特殊访问权限，该基类的派生类不能访问授予友元关系的类。

### 1.6 继承与静态成员

如果基类定义 static 成员，则整个继承层次中只有一个这样的成员。无论从基类派生出多少个派生类，每个 static 成员只有一个实例。static 成员遵循常规访问控制：如果成员在基类中为 private，则派生类不能访问它。假定可以访问成员，则既可以通过基类访问 static 成员，也可以通过派生类访问 static 成员。一般而言，既可以使用作用域操作符也可以使用点或箭头成员访问操作符。

---
## 2 虚函数

虚函数是在基类中使用关键字 virtual 声明的函数。为了指明函数为虚函数，在其返回类型前面加上保留字 virtual。除了构造函数之外，任意非 static 成员函数都可以是虚函数。一旦函数在基类中声明为虚函数，它就一直为虚函数，派生类无法改变该函数为虚函数这一事实。派生类重定义虚函数时，可以使用 virtual 保留字，也可以不指定。

### 2.1 动态绑定

关键字 virtual 的目的是启用动态绑定。成员默认为非虚函数，对非虚函数的调用在编译时确定，而对虚函数的调用则是运行时确认的。

**动态绑定**：在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数。在程序中任意点根据所调用的对象类型来选择所调用的函数版本，这种操作被称为动态链接，也叫后期绑定或动态绑定。

动态绑定的条件，C++ 中的函数调用默认不使用动态绑定。要触发动态绑定，满足两个条件：

1. 只有指定为虚函数的成员函数才能进行动态绑定，成员函数默认为非虚函数，非虚函数不进行动态绑定;
2. 必须通过基类类型的引用或指针进行函数调用。

### 2.2 静态链接

如果基类中的函数不是虚函数，那么即使派生类重写了该函数，当以 **基类形态** 去调用实际类型为派生类的函数时，调用的是基类中的函数。即函数调用在程序执行前就准备好了。有时候这也被称为早绑定。

### 2.3 纯虚函数

在基类中不对虚函数给出有意义的实现，这个时候就是纯虚函数。

虚函数声明：`virtual ReturnType FunctionName(Parameter) = 0` ，虚函数必须实现，如果不实现，编译器将报错

- 纯虚函数一定没有定义，纯虚函数用来规范派生类的行为，即接口。
- 包含纯虚函数的类是抽象类，抽象类不能定义实例，但可以声明指向实现该抽象类的具体类的指针或引用。
- 对于虚函数来说，父类和子类都有各自的版本。由多态方式调用的时候动态绑定。
- 虚函数是 C++ 中用于实现多态(polymorphism)的机制。核心理念就是通过基类访问派生类定义的函数。
- 在有动态分配堆上内存的时候，析构函数必须是虚函数，但没有必要是纯虚的。
- 友元不是成员函数，只有成员函数才可以是虚拟的，因此友元不能是虚拟函数。但可以通过让友元函数调用虚拟成员函数来解决友元的虚拟问题。
- 析构函数应当是虚函数，将调用相应对象类型的析构函数，因此，**如果指针指向的是子类对象，将调用子类的析构函数，然后自动调用基类的析构函数**。
- 如果基类的虚函数不是纯虚函数，则派生类可以在实现中调用基类的虚函数。

### 2.4 多态性

当类之间存在层次结构，并且类之间是通过继承关联时，就会用到多态。C++ 多态意味着调用成员函数时，会根据调用函数的对象的类型来执行不同的函数。

### 2.5 覆盖虚函数机制

在某些情况下，希望覆盖虚函数机制并强制函数调用使用虚函数的特定版本，这里可以使用作用域操作符

```cpp
DerivedClass derived;
BaseClass *baseP = &derived;
// 这里从基类 Parent 调用版本，而不考虑动态类型的 baseP。
double d = baseP->BaseClass::method(42);
```

### 2.6 虚函数与默认实参

- 通过基类的引用或指针调用虚函数时，默认实参为在基类虚函数声明中指定的值，如果通过派生类的指针或引用调用虚函数，则默认实参是在派生类的版本中声明的值。
- 在同一虚函数的基类版本和派生类版本中使用不同的默认实参几乎一定会引起麻烦。

---
## 3 转换与继承

### 3.1 派生类到基类的转换

- 一个是派生类对象转换为基类类型引用，引用直接绑定到该对象，没有复制行为。
- 一个是用派生类对象对基类对象进行初始化或赋值，则该派生类对象的基类部分被复制到形参，此时基类对象中没有派生类成员的存储空间。即**对象切片**。

### 3.2 派生类到基类转换的可访问性

要确定到基类的转换是否可访问，可以考虑基类的 public 成员是否访问，如果可以，转换是可访问的，否则，转换是不可访问的。

- 如果是 public 继承，则用户代码和后代类都可以使用派生类到基类的转换。
- 如果类是使用 private 或 protected 继承派生的，则用户代码不能将派生类型对象转换为基类对象。
- 如果是 private 继承，则从 private 继承类派生的类不能转换为基类。
- 如果是 protected 继承，则后续派生类的成员可以转换为基类类型。

### 3.3 基类到派生类的转换

- 从基类到派生类的自动转换是不存在的。需要派生类对象时不能使用基类对象。
- 如果知道从基类到派生类的转换是安全的，就可以使用 `static_cast` 强制编译器进行转换。或者，可以用 `dynamic_cast` 申请在运行时进行检查。

---
## 4 构造函数和复制控制

**构造函数和复制控制成员不能继承**，每个类定义自己的构造函数和复制控制成员。像任何类一样，如果类不定义自己的默认构造函数和复制控制成员，就将使用合成版本。

### 4.1 派生类构造函数

#### 合成的派生类默认构造函数

派生类的合成默认构造函数与非派生的构造函数只有一点不同，即除了初始化派生类的数据成员之外，它还初始化派生类对象的基类部分。基类部分由基类的默认构造函数初始化。

```cpp
class A{
public:
    std:string name;
    int a;
}

class B: A{
public:
    int b;
}
```

对于 B 类，合成的默认构造函数会这样执行：

- 调用 A 的默认构造函数，将 name 成员初始化空串，将 a 成员初始化为 0。
- B 的成员初始化取决于 B 类所在的存储类型(局部或者全局)

派生类定义构造函数时，如果不显式调用基类的构造函数，则构造函数还隐式调用基类的默认构造函数初始化对象的基类部分。

#### 向基类构造函数传递实参

使用定义的构造函数可以向基类构造函数传递实参来初始化基类成员。

```cpp
DerivedClass(...paramster):BaseClass(paramster1, paramster2),filed1(paramster3), filed2(paramster4) {

}
```

#### 只能初始化直接基类

一个类只能初始化自己的直接基类。直接就是在派生列表中指定的类。如果类 C 从类 B 派生，类 B 从类 A 派生，则 B 是 C 的直接基类。

### 4.2 复制控制和继承

#### 合成的继承复制构造函数

合成的继承复制构造函数会负责复制积累部分。

#### 定义派生类复制构造函数

如果派生类显式定义自己的复制构造函数或赋值操作符，则该定义将完全覆盖默认定义。**被继承类的复制构造函数和赋值操作符负责对基类成分以及类自己的成员进行复制或赋值**。

如果派生类定义了自己的复制构造函数，该复制构造函数一般应**显式使用**基类复制构造函数初始化对象的基类部分：

```cpp
class Base { /* ... */ };

class Derived: public Base {

public:
    Derived(const Derived& d):Base(d)

}
```

### 4.3 派生类赋值操作符

赋值操作符通常与复制构造函数类似：如果派生类定义了自己的赋值操作符，则该操作符必须对基类部分进行显式赋值。

```cpp
Base::operator=(const Base&) //不自动调用

Derived &Derived::operator=(const Derived &rhs){
    if (this != &rhs) {
        Base::operator=(rhs); //调用基类
        // 然后在做其他复制操作
    }
    return *this;
}
```

### 4.4 派生类析构函数

析构函数的工作与复制构造函数和赋值操作符不同：派生类析构函数不负责撤销基类对象的成员。编译器总是自动调用派生类对象基类部分的析构函数。每个析构函数只负责清除自己的成员，**对象的撤销顺序与构造顺序相反**：首先运行派生析构函数，然后按继承层次依次向上调用各基类析构函数。

### 4.4 虚析构函数

- [ ] todo

---
## 5 继承情况下的类作用域

- [ ] todo

---
## 6 多继承

多继承即一个子类可以有多个父类，它继承了多个父类的特性。

```cpp
class <derived-class>: <inheritance-mode 1><base-class1>,: <inheritance-mode 2><base-class2>, …
{

};
```

---
## 7 接口（抽象类）

接口描述了类的行为和功能，而不需要完成类的特定实现。如果类中至少有一个函数被声明为纯虚函数(包括定义的和继承的)，则这个类就是抽象类。设计抽象类的目的是为了给其他类提供一个可以继承的适当的基类。抽象类不能被用于实例化对象，它只能作为接口使用。
