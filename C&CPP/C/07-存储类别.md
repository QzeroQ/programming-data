# 存储类别

---
## 1 存储类

### 1.1 作用域

作用域描述了一个程序可以访问一个标识符的一个或多个区域。一个C变量的作用域可以是：**文件作用域、块级作用域、函数原形作用域**。函数原形作用域适用于函数原型中的变量名。

```c
//unists具有文件作用域，更准确的说，它具有外部连接文件作用域
int unists = 0;

int main(){

}
```

>**翻译单元和文件**：你认为的多个文件在编译器中可以以单个文件出现，例如在源代码中包含一个或者多个头文件，头文件会一次包含其他头文件，所以会包含多个独立的物理文件，但是C预处理实际上是用包含的头文件替换#include指令，所以编译器源代码文件和所有的头文件都看成是一个包含信息的单独文件，这个文件被称为翻译单元(translation unit)。描述一个具有文件作用域的变量时，它实际的可见范围是整个翻译单元，如果程序由多个源代码文件组成，那么该程序也将由多个翻译单元组成，每个翻译单元均对应一个源代码文件和它对应的多个包换的文件。

---
### 1.2 链接

C变量具有三种连接属性：**外部链接、内部链接、无链接**。无链接对应的变量作用域：`函数作用域、块级作用域、函数原形作用域`。具有文件作用域的变量可以是外部链接或者内部链接：

- 内部链接(External Linkage)：只能在一个翻译单元中使用
- 外部链接(Internal Linkage)：可以在多文件程序中使用
- 无链接(No Linkage)：除以上情况之外的标识符都属于无连接的，例如函数的局部变量，以及不表示变量和函数的其它标识符。

```c
//文件作用域，外部链接，称为内部链接文件作用域，简称文件作用域
int giants = 5;
//文件作用域，内部链接，称为外部链接文件作用域，简称全局作用域或程序作用域
static int dodgers = 4;
int main(){}
```

### 1.3 存储时期

C 变量具有四种存储时期：

- 静态存储时期，外部链接和内部链接都是静态存储期，如果一个变量是静态存储期的，那么它将在程序运行期间一直存在，全局变量具有的是静态存储时期。
- 自动存储时期，块级作用域的变量一般具有的是自动存储时期，程序进入代码块是，自动为变量分配内存，退出块时，分配的内存将被释放。
- 线程存储期：用于并发设计。
- 动态分配存储期：使用 `malloc()` 申请内存。

**对于文件作用域变量，关键字 static 表明的是链接属性，而不是存储期**。

### 1.4 存储类

C使用作用域、链接、存储时期来定义5钟存储类：自动、寄存器、具有代码块作用域的静态、具有外部链接的静态、具有内部连接的静态。

存储类别列表：

存储类别|存储期|作用域|链接|声明方式
---|---|---|---|---|
自动|自动|块|无|块内
寄存器|自动|块|无|块内，register 修饰
静态外部链接|静态|文件|外部|所有函数外
静态内部链接|静态|块|内部|所有函数外，使用 static 修饰
静态无链接(空连接)|静态|块|无|块内，使用 static 修饰

>**多文件**：只有当程序有多个翻译单元组成时，才体现区别内部变量和外部变量的重要性。复杂的C程序通常由多个翻译单元组成，有时这些文件需要共享一个外部变量，C通过在一个文件中进行定义式声明，然后在其他文件中进行引用式声明来实现共享。

### 1.5 存储类别说明符（Storage Class Specifier）

关键字 static 和 extern 的含义取决于上下文，C 语言有 6 个关键字作为存储类别声明符：`auto、register、extern、static、_Thread_local 和 typedef(语法原因归于此处)`。大多数情况下不能同时使用多个存储类别说明符，不能将任一存储类别说明符作为 typedef 的一部分。唯一列外的是`_Thread_local`，它可以和 `static和extern` 一起使用。

- auto 用它修饰的变量在函数调用时自动在栈上分配存储空间，函数返回时自动释放，auto可以省略不写，auto不能修饰文件作用域的变量。
- register 编译器对于用register修饰的变量会尽可能分配一个专门的寄存器来存储，但如果实在分配不开寄存器，编译器就把它当auto变量处理了，register不能修饰文件作用域的变量。现在一般编译器的优化都做得很好了，它自己会想办法有效地利用CPU的寄存器，所以现在register关键字也用得比较少了。
- static 用它修饰的变量的存储空间是静态分配的，用它修饰的文件作用域的变量或函数具有Internal Linkage。
- extern 说明符表明声明的变量定义在别处。链接属性是根据一个标识符多次声明时是不是代表同一个变量或函数来分类的，extern 关键字就用于多次声明同一个标识符。

**定义和声明**：extern 用于声明需要用到定义在别处的变量，而不是用来定义变量，不要用 extern 来定义变量。

>typedef 它并不是用来修饰变量的，而是定义一个类型名。看typedef声明怎么看呢，首先去掉typedef把它看成变量声明，看这个变量是什么类型的，那么typedef就定义了一个什么类型，也就是说，typedef在语法结构中出现的位置和前面几个关键字一样，也是修饰变量声明的，所以从语法（而不是语义）的角度把它和前面几个关键字归类到一起。

**extern 是 Previous Linkage 的**：准确地说 extern 应该是 Previous Linkage。Previous Linkage 的定义是：`这次声明的标识符具有什么样的Linkage取决于前一次声明，这前一次声明具有相同的标识符名，而且必须是文件作用域的声明，如果在程序文件中找不到前一次声明（这次声明是第一次声明），那么这个标识符具有External Linkage`。例如在一个程序文件中在文件作用域两次声明同一个函数：

```c
static int f(void); /* internal linkage */
//这里的extern修饰的标识符具有Interanl Linkage而不是External Linkage。
extern int f(void); /* previous linkage */
```

### 1.6 分配内存：malloc() 和  free()

上面介绍的五种存储类的共同点是：在决定了使用哪种存储类后，就自动决定了作用域和存储时期，这符合预先指定的内存管理规则。除了上面介绍的五种存储类之外，还有更灵活的方式来管理内存。及使用库函数来手动管理内存。

### 1.7 变量的生存期（Storage Duration）

- 静态生存期（Static Storage Duration），具有外部或内部链接属性，或者被static修饰的变量，在程序开始执行时分配和初始化一次，此后便一直存在直到程序结束。
- 自动生存期（Automatic Storage Duration），链接属性为无链接并且没有被static修饰的变量，这种变量在进入块作用域时在栈上或寄存器中分配，在退出块作用域时释放。
- 动态分配生存期（Allocated Storage Duration），调用malloc函数在进程的堆空间中分配内存，调用free函数可以释放这种存储空间。

---
## 2 存储类别和函数

函数也有存储类别：

- 外部函数(默认)
- 静态函数
- 内联函数(C99)

```c
double gamma(double);//该函数为外部函数
static doble beta(int,int);//该函数为静态函数
extern double delte(double,int);//用extern来声明定义在其他文件的函数
```

---
## 3 存储类别选择

存储类别选择：优先使用自动存储类别。不要轻易定义共享变量，以防止该变量被篡改，唯一例外的是const数据。因为它们在初始化以后不会被修改。**定义变量的法则：**按需知道，尽量在函数内部解决所有任务，只共享那些需要共享的变量

---
## 4 ANSI C 类型限定符（Type Qualifier）

通常用类型(比如 int )和存储类别(比如 auto)来描述一个变量。

- C90 新增了两个属性：恒常性和易变性
  - 恒常性，对应 const 关键字，const 用于定义常量
  - 易变性，对应 volatile 关键字，告诉编译器该变量处理可以被程序修改外，还可以被其他代理修改，即使在编译时指定了优化选项，每次读这个变量仍然要老老实实从内存读取，每次写这个变量也仍然要老老实实写回内存，不能省略任何步骤。
- C99 新增了第三个限定符：`restrict`用于提高编译器优化，具体参考[字符串操作函数](https://akaedu.github.io/book/ch25s01.html)。
- C11 新增了第四个限定符：`_Atomic`