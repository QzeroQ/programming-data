# 预处理

C语言建立在适当的关键字、表达式、语句以及使用它们的规则上。C标准不仅描述C语言，还描述如何执行C预处理器、C标准库有哪些函数，以及详述这些函数的工作原理。

C语言源文件要经过编译、链接才能生成可执行程序：

- 编译（Compile）会将源文件（`.c`文件）转换为目标文件。对于VC/VS，目标文件后缀为`.obj`；对于GCC，目标文件后缀为`.o`。
- 链接（Link）是针对多个文件的，它会将编译生成的多个目标文件以及系统中的库、组件等合并成一个可执行程序。

但是在编译和连接之前，通常还有一个步骤——**预处理**

---
## 1 C 预处理器

C预处理器不是编译器的组成部分，它是编译过程中一个单独的步骤。C预处理器只是一个文本替换工具，它们会指示编译器在实际编译之前完成所需的预处理。通常将把C预处理器（C Preprocessor）简写为 CPP。

根据程序中的预处理器指令，预处理器把符号缩写替换成其表示的内容。预处理器可以包含程序所需的其他文件，可以选择让编译器查看哪些代码。预处理器并不知道C。基本上它的工作是把一些文本转换成另外一些文本。

所有的预处理器命令都是以井号（#）开头。它必须是第一个非空字符，为了增强可读性，预处理器指令应从第一列开始。

### 预处理指令

- `define`：定义宏
- `include`：包含一个源代码文件
- `undef`：取消已定义的宏
- `ifdef`：如果宏已经定义，则返回真
- `ifndef`：如果宏没有定义，则返回真
- `if`：如果给定条件为真，则编译下面代码
- `else`：#if 的替代方案
- `elif`：如果前面的 #if 给定条件不为真，当前条件为真，则编译下面代码
- `endif`：结束一个 #if……#else 条件编译块
- `error`：当遇到标准错误时，输出错误消息
- `pragma`：使用标准化方法，向编译器发布特殊的命令到编译器中

### 预定义宏

- `__DATE__`：当前日期，一个以 "MMM DD YYYY" 格式表示的字符常量。
- `__TIME__`：当前时间，一个以 "HH:MM:SS" 格式表示的字符常量。
- `__FILE__`：这会包含当前文件名，一个字符串常量。
- `__LINE__`    ：这会包含当前行号，一个十进制常量。
- `__STDC__`    ：当编译器以ANSI标准编译时，则定义为 1。
- `__STDC_VERSION__`    ：为C99时设置为199901L
- `__VA_ARGS__`：用于定义带参数的宏时说明参数是可变参数

务必要注意：**预处理器只是一个文本替换工具**

---
## 2 `#include`命令

`#include`是文件包含命令，主要用来引入对应的头文件。`#include` 的处理过程很简单，就是将头文件的内容插入到该命令所在的位置，从而把头文件和当前源文件连接成一个源文件，这与复制粘贴的效果相同。

`#include` 指令有两种形式：

```c
#include <stdio.h>            ←查找系统目录
#include "hot.h"              ←查找当前工作目录
#include "/usr/biff/p.h"      ←查找/usr/biff目录
```

---
## 3 明示常量：`#define`

`#define`用于定义宏，宏定义是预处理命令的一种，它允许用一个标识符来表示一个字符串。一般用于定义常量或者表达式。宏定义注意：

- 宏定义是用宏名来表示一个字符串，在宏展开时又以该字符串取代宏名，这只是一种简单的替换。字符串中可以含任何字符，可以是常数，也可以是表达式，预处理程序对它不作任何检查，如有错误，只能在编译已被宏展开后的源程序时发现。
- 宏定义不是说明或语句，在行末不必加分号，如加上分号则连分号也一起替换。、
- 宏定义必须写在函数之外，其作用域为宏定义命令起到源程序结束。如要终止其作用域可使用#undef命令。
- 宏定义与 typedef 是不一样的。 typedef 是类型定义，是有类型的。宏定义虽然也可表示数据类型， 但毕竟是作字符代换。在使用时要分外小心，以避出错。

语法：

- `#`运算符用于创建字符串，`#` 运算符后面应该跟一个形参（中间可以有空格或Tab）
- `##`运算符把前后两个预处理 Token 连接成一个预处理 Token，和#运算符不同，`##` 运算符不仅限于函数式宏定义，变量式宏定义也可以用。
- 可变参数的部分用`__VA_ARGS__`表示，实参中对应`...`的几个参数可以看成一个参数替换到宏定义中`__VA_ARGS__`所在的地方。

示例:

```c
#include <stdio.h>

#define STR "hello, "\
"world"

#define MAX(a,b) ( (a) > (b)? (a) : (b) )

#define CONCAT(x,y) x##y

#define TO_STR(a) #a

#define debug(...) printf(__VA_ARGS__)

int main(int argc, char const *argv[])
{
    // printf("result = %s",FOO(1));
    // printf("result = %s",FOO(1,2,3,));
    printf("%s\n",STR);
    int max = MAX(1,2);
    printf("%d\n",max);
    printf("%d\n",CONCAT(2,3));
    printf("%s\n",TO_STR("222    4444"));
    debug("Y = %d\n", 20);

    return 0;
}
```

### 重定义常量

```c
#define EIGHT 4 * 8
```

假设先把LIMIT 定义为20 ，稍后在该文件中又把它定义为25 。这个过程称为重定义常量。不同的实现采用不同的重定义方案。

- 除非新定义与旧定义相同，否则有些实现会将其视为错误。
- 另外一些实现允许重定义，但会给出警告。

ANSI标准采用第1种方案，只有新定义和旧定义完全相同才允许重定义。

```c
// 这两条定义都有3个相同的记号，额外的空格不算替换体的一部分。
// 具有相同的定义意味着替换体中的记号必须相同，且顺序也相同。因此，下面两个定义相同：
#define SIX 2 * 3
#define SIX 2 * 3

// 而下面的定义则与上面两条宏定义不同：
// 这条宏定义中只有一个记号，如果需要重定义宏，使用 #undef 指令。
#define SIX 2*3
```

### 在 `#define` 中使用参数

在 `#define` 中使用参数可以创建外形和作用与函数类似的类函数宏。但是注意，但是它的行为和函数调用完全不同。

#### 用宏参数创建字符串：`#运算符`

```c
#define PSQR(X) printf("The square of X is %d.\n", ((X)*(X)));
//展开后：The square of X is 64.
PSQR(8);
```

#### 预处理器黏合剂：`##运算符`

与 `#` 运算符类似，`##` 运算符可用于类函数宏的替换部分。而且，`##` 还可用于对象宏的替换部分。`##` 运算符把两个记号组合成一个记号。

```c
#define XNAME(n) x ## n
//PRINT_XN() 宏用 # 运算符组合字符串，## 运算符把记号组合为一个新的标识符。
#define PRINT_XN(n) printf("x" #n " = %d\n", x ## n);

int main(void)
{
    int XNAME(1) = 14;      // 变成 int x1 = 14;
    int XNAME(2) = 20;     // 变成 int x2 = 20;
    int x3 = 30;
    PRINT_XN(1);            // 变成 printf("x1 = %d\n", x1);
    PRINT_XN(2);            // 变成 printf("x2 = %d\n", x2);
    PRINT_XN(3);            // 变成 printf("x3 = %d\n", x3);
    return 0;
}

//输出：
x1 = 14
x2 = 20
x3 = 30
```

#### 变参宏：`...` 和`__VA_ARGS__`

`__VA_ARGS__`可用在替换部分中，表明省略号代表什么：

```c
//定义
#define PR(X, ...) printf("Message " #X ": " __VA_ARGS__)
//使用
PR(1, "x = %g\n", x);
PR(2, "x = %.2f, y = %.4f\n", x, y);
```

#### 宏和函数的选择

有些编程任务既可以用带参数的宏完成，也可以用函数完成。应该使用宏还是函数？这没有硬性规定，但是可以参考下面的情况。

- 使用宏比使用普通函数复杂一些，稍有不慎会产生奇怪的副作用。一些编译器规定宏只能定义成一行。不过，即使编译器没有这个限制，也应该这样做。
- 宏和函数的选择实际上是时间和空间的权衡。宏生成内联代码，即在程序中生成语句。如果调用20次宏，即在程序中插入20行代码。如果调用函数20次，程序中只有一份函数语句的副本，所以节省了空间。然而另一方面，程序的控制必须跳转至函数内，随后再返回主调程序，这显然比内联代码花费更多的时间。
- 宏的一个优点是，不用担心变量类型（这是因为宏处理的是字符串，而不是实际的值）。因此，只要能用 int 或 float 类型都可以使用 SQUARE(x) 宏。
- C99 提供了第3种可替换的方法——内联函数。

对于简单的函数，通常选择宏：

```c
#define MAX(X,Y) ((X) > (Y) ? (X) : (Y))
#define ABS(X) ((X) < 0 ? -(X) : (X))
#define ISSIGN(X) ((X) == '+' || (X) == '-' ? 1 : 0)
```

使用宏需要注意以下几点：

1. 记住宏名中不允许有空格，但是在替换字符串中可以有空格。ANSI C允许在参数列表中使用空格。
2. 用圆括号把宏的参数和整个替换体括起来。这样能确保被括起来的部分在类似 `forks = 2 * MAX(guests + 3, last);` 这样的表达式中正确地展开。
3. 用大写字母表示宏函数的名称。该惯例不如用大写字母表示宏常量应用广泛。但是，大写字母可以提醒程序员注意，宏可能产生的副作用。
4. 如果打算使用宏来加快程序的运行速度，那么首先要确定使用宏和使用函数是否会导致较大差异。在程序中只使用一次的宏无法明显减少程序的运行时间。在嵌套循环中使用宏更有助于提高效率。许多系统提供程序分析器以帮助程序员压缩程序中最耗时的部分。

---
## 4 条件编译

能够根据不同情况编译不同代码、产生不同目标文件的机制，称为条件编译。条件编译是预处理程序的功能，不是编译器的功能。`if、ifdef、ifndef`等预处理指令用于实现条件编译。条件编译在预处理阶段完成的，多余的代码以及所有的宏都不会参与编译，不仅保证了代码的正确性，还减小了编译后文件的体积。

---
## 5 #error 和 #line

`#line`用于重置由 `__LINE__`和`__FILE__`宏报告的行号和文件名，使用方式为

```c
#line 1000//重置行号
#line 2000 "aa.c"//重置行号和文件名
```

`#error`指令使预处理器发出一条错误信息，该消息包含指令中的文本。可能的话编译过程应该被终端。使用方式为

```c
#if __STDC_VERSION__ == 1999901L
#error NOT C99
#endif
```
