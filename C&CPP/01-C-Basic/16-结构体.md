# 结构体

数组只能存储类型相同的元素，如果需要在一个数据结果中存储不同的数据类型，可以使用结构体。

## 1 结构声明（structure declaration ）

结构声明（structure declaration ）描述了一个结构的组织布局。声明类似下面这样：

```c
    //语法：
    struct 标记名 {
        字段1;
        ...
    }

    //示例：
    struct Student {
        int num;            //4
        char name[20];      //20
        char sex;           //1
        int age;            //4
        float score;        //4
        char address[20];   //20
    };
```

结构体内部的元素可以称为**成员列表或域表**

- 结构体中可以嵌套声明。
- 声明结构体只是定义了一种数据模型，并没有定义变量，其本身不占内存。

## 2 定义结构体

结构有两层含义。

- 一层含义是“结构布局”，即结构声明。结构布局告诉编译器如何表示数据，但是它并未让编译器为数据分配空间。
- 另一层含义：程序中创建结构变量。

```c
//声明结构体
struct book {
    char title[MAXTITL];
    char author[MAXAUTL];
    float value;
};

//创建一个结构变量，即是结构的另一层含义。
struct book library;
```

声明且定义结构体：

```c
    struct Date1 {
        int month;
        int year;
        int day;
    } date1, date2;
```

匿名结构体，创建结构体时可以不指定结构的标记名：

```c
int main(){

    struct {
        int month;
        int year;
        int day;
    } date3;

    ...

}
```

## 3 初始化结构

```c
//定义然后初始化
struct book library;
book.title = "C Primer Plus";

//定义且初始化
struct book library = {
    "The Pious Pirate and the Devious Damsel",
    "Renee Vivotte",
    1.95
}

//C99和C11为结构提供了指定初始化器（designated initializer ），可以按照任意顺序使用指定初始化器。
struct book gift = {
    .value = 25.99,
    .author = "James Broadfool",
    .title = "Rue for the Toad"
};
```

## 4 结构体嵌套

结构体可以嵌套声明：

```c
// 第1个结构
struct names {
    char first[LEN];
    char last[LEN];
};

// 第2个结构
struct guy {
    // 嵌套结构
    struct names handle;
    char favfood[LEN];
    char job[LEN];
    float income;
};
```

嵌套结构体初始化：

```c
  // 初始化一个结构变量
  struct guy fellow = {
            { "Ewen", "Villard" },
            "grilled salmon",
            "personality coach",
            68112.00
    };
```

## 5 函数与结构体

结构体作为函数参数或返回值时：本质是重新创建一个副本作为实参或返回值，而使用结构体指针可以避免隐含的内存复制操作，那么结构和结构指针如何选择呢？

1. 把结构作为参数传递的优点是，函数处理的是原始数据的副本，这保护了原始数据。另外，代码风格也更清楚。
2. 传递结构的两个缺点是：较老版本的实现可能无法处理这样的代码，而且传递结构浪费时间和存储空间。尤其是把大型结构传递给函数，而它只使用结构中的一两个成员时特别浪费。这种情况下传递指针或只传递函数所需的成员更合理。
3. 通常，了追求效率会使用结构指针作为函数参数，如需防止原始数据被意外修改，使用 const 限定符。按值传递结构是处理小型结构最常用的方法。

## 6 结构体之间的赋值

C 允许把一个结构赋值给另一个结构，但是数组不能这样做。也就是说，如果 n_data 和 o_data 都是相同类型的结构，可以这样做：

```c
// 把一个结构赋值给另一个结构
o_data = n_data;  
```

这条语句把 n_data 的每个成员的值都赋给 o_data 的相应成员。即使成员是数组，也能完成赋值。

另外，还可以把一个结构初始化为相同类型的另一个结构：

```c
struct names right_field = {"Ruthie", "George"};

// 把一个结构初始化为另一个结构
struct names captain = right_field;
```

## 7 在结构体中声明指针

```c
struct pnames {
    char * first;
    char * last;
};
```

如果要用结构储存字符串，用字符数组作为成员比较简单。用指向 char 的指针也行，但是误用会导致严重的问题（忘记分配空间而直接使用结构体中的指针接收数据）。如果使用 `malloc()` 分配内存并使用指针储存该地址，那么在结构中使用指针处理字符串就比较合理。这种方法的优点是，可以请求 `malloc()` 为字符串分配合适的存储空间。比如：

```c
struct namect {
    char * fname;    // 用指针代替数组
    char * lname;
    int letters;
};

//初始化结构体
void createInfo (struct namect * pst){
    char temp[SLEN];
    printf("Please enter your first name.\n");
    s_gets(temp, SLEN);
    // 分配内存储存名
    pst->fname = (char *) malloc(strlen(temp) + 1);
    // 把名拷贝到已分配的内存
    strcpy(pst->fname, temp);
    printf("Please enter your last name.\n");
    s_gets(temp, SLEN);
    pst->lname = (char *) malloc(strlen(temp) + 1);
    strcpy(pst->lname, temp);
}

//通常还应该配套提供一个释放结构体的方法
void releaseInfo(struct namect * pst){
    ...
}
```

## 8 位域

使用位域可以更好的利用内存空间。 位域声明：

```c
 struct
    {
      type [member_name] : width ;
    };
```

- ``type``：整数类型，决定了如何解释位域的值。类型可以是整型、有符号整型、无符号整型。
- ``member_name``：位域的名称。
- ``width``：位域中位的数量。宽度必须小于或等于指定类型的位宽度。

关于位域有以下特点：

- 一个位域必须存储在同一个字节中，不能跨两个字节。如一个字节所剩空间不够存放另一位域时，应从下一单元起存放该位域。也可以有意使某位域从下一单元开始。
- 由于位域不允许跨两个字节，因此位域的长度不能大于一个字节的长度。
- 位域可以无位域名，这时它只用来作填充或调整位置。无名的位域是不能使用的。
