# 存储类别

涉及内容：如何确定变量的作用域（可见的范围）和生命期（它存在多长时间）。

---
## 1 存储类别

### 1.1 作用域

作用域描述了一个程序可以访问一个标识符的一个或多个区域。一个C变量的作用域可以是：**文件作用域、块级作用域、函数原形作用域**。函数原形作用域适用于函数原型中的变量名。

```c
//unists具有文件作用域，更准确的说，它具有外部连接文件作用域
int unists = 0;

int main(){

}
```

---
### 1.2 链接

C变量具有三种连接属性：**外部链接、内部链接、无链接**。无链接对应的变量作用域：`函数作用域、块级作用域、函数原形作用域`。具有文件作用域的变量可以是外部链接或者内部链接：

外部链接变量可以在多文件程序中使用，内部链接变量只能在一个翻译单元中使用。

- 内部链接(External Linkage)：只能在一个翻译单元中使用。
- 外部链接(Internal Linkage)：可以在多文件程序中使用。
- 无链接(No Linkage)：除以上情况之外的标识符都属于无连接的，例如函数的局部变量，以及不表示变量和函数的其它标识符。

```c
//文件作用域，外部链接，称为内部链接文件作用域，简称文件作用域
int giants = 5;
//文件作用域，内部链接，称为外部链接文件作用域，简称全局作用域或程序作用域
static int dodgers = 4;

int main(){

}
```

**翻译单元和文件**：你认为的多个文件在编译器中可以以单个文件出现，例如在源代码中包含一个或者多个头文件，头文件会一次包含其他头文件，所以会包含多个独立的物理文件，但是C预处理实际上是用包含的头文件替换#include指令，所以编译器源代码文件和所有的头文件都看成是一个包含信息的单独文件，这个文件被称为翻译单元(translation unit)。描述一个具有文件作用域的变量时，它实际的可见范围是整个翻译单元，如果程序由多个源代码文件组成，那么该程序也将由多个翻译单元组成，每个翻译单元均对应一个源代码文件和它对应的多个包换的文件。

**多文件**：只有当程序由多个翻译单元组成时，才体现区别内部链接和外部链接的重要性。复杂的C程序通常由多个单独的源代码文件组成。有时，这些文件可能要共享一个外部变量。C通过在一个文件中进行定义式声明，然后在其他文件中进行引用式声明来实现共享。也就是说，除了一个定义式声明外，其他声明都要使用extern关键字。而且，只有定义式声明才能初始化变量。

**正式和非正式术语**：C 标准用“内部链接的文件作用域”描述仅限于一个翻译单元（即一个源代码文件和它所包含的头文件）的作用域，用“外部链接的文件作用域”描述可延伸至其他翻译单元的作用域。一些程序员把“内部链接的文件作用域”简称为“文件作用域”，把“外部链接的文件作用域”简称为“全局作用域”或“程序作用域”。

### 1.3 存储时期

作用域和链接描述了标识符的可见性。存储期描述了通过这些标识符访问的对象的生存期。C 变量具有四种存储时期：

- **静态存储时期**（Static Storage Duration），外部链接和内部链接都是静态存储期，如果一个变量是静态存储期的，那么它将在程序运行期间一直存在，全局变量具有的是静态存储时期。
- **自动存储时期**（Automatic Storage Duration），链接属性为无链接并且没有被static修饰的变量，这种变量在进入块作用域时在栈上或寄存器中分配，在退出块作用域时释放。
- **线程存储期**（Thread Storage Duration）：用于并发设计。程序执行可被分为多个线程。具有线程存储期的对象，从被声明时到线程结束一直存在。以关键字 `_Thread_local` 声明一个对象时，每个线程都获得该变量的私有备份。
- **动态分配存储期**（Allocated Storage Duration）：调用malloc函数在进程的堆空间中分配内存，调用free函数可以释放这种存储空间，具体参考[动态内存管理](22-动态内存管理.md)。

**注意**：对于文件作用域变量，关键字 static表明了其链接属性，而非存储期。以 static声明的文件作用域变量具有内部链接。但是无论是内部链接还是外部链接，所有的文件作用域变量都具有静态存储期。

### 1.4 存储类

C使用作用域、链接、存储时期来定义5钟存储类：自动、寄存器、具有代码块作用域的静态、具有外部链接的静态、具有内部连接的静态。

存储类别列表：

存储类别|存储期|作用域|链接|声明方式
---|---|---|---|---|
自动|自动|块|无|块内
寄存器|自动|块|无|块内，register 修饰
静态外部链接|静态|文件|外部|所有函数外
静态内部链接|静态|块|内部|所有函数外，使用 static 修饰
静态无链接(空连接)|静态|块|无|块内，使用 static 修饰

### 1.5 存储类别说明符（Storage Class Specifier）

关键字 static 和 extern 的含义取决于上下文，C 语言有 6 个关键字作为存储类别声明符：`auto、register、extern、static、_Thread_local 和 typedef(语法原因归于此处)`。大多数情况下不能同时使用多个存储类别说明符，不能将任一存储类别说明符作为 typedef 的一部分。唯一列外的是`_Thread_local`，它可以和 `static和extern` 一起使用。

- auto 用它修饰的变量在函数调用时自动在栈上分配存储空间，函数返回时自动释放，auto可以省略不写，auto不能修饰文件作用域的变量。
- register 编译器对于用register修饰的变量会尽可能分配一个专门的寄存器来存储，但如果实在分配不开寄存器，编译器就把它当auto变量处理了，register不能修饰文件作用域的变量。现在一般编译器的优化都做得很好了，它自己会想办法有效地利用CPU的寄存器，所以现在register关键字也用得比较少了。
- static 用它修饰的变量的存储空间是静态分配的，用它修饰的文件作用域的变量或函数具有Internal Linkage。
- extern 说明符表明声明的变量定义在别处。链接属性是根据一个标识符多次声明时是不是代表同一个变量或函数来分类的，extern 关键字就用于多次声明同一个标识符。

### 1.6 extern 详细说明

**定义和声明**：extern 用于声明需要用到定义在别处的变量，而不是用来定义变量，不要用 extern 来定义变量，该声明并不会引起分配存储空间。

- 如果想指出在函数使用了外部变量，也可以在函数中用关键字 extern 再次声明。
- 如果一个源代码文件使用的外部变量定义在另一个源代码文件中，则必须用extern在该文件中声明该变量。

```c
/* 外部定义的变量 */
int Errupt;
/* 外部定义的数组 */
double Up[100];
/* 如果Coal被定义在另一个文件*/
extern char Coal;

/*则必须这样声明*/
void　next(void);

int　main(void){
    /* 可选的声明，表示使用在别处定义的 Errupt*/
    extern int Errupt;
    /* 可选的声明*/
    extern double Up[];　　
    ...
}

void　next(void){
    ...
}
```

>typedef 它并不是用来修饰变量的，而是定义一个类型名。看typedef声明怎么看呢，首先去掉typedef把它看成变量声明，看这个变量是什么类型的，那么typedef就定义了一个什么类型，也就是说，typedef在语法结构中出现的位置和前面几个关键字一样，也是修饰变量声明的，所以从语法（而不是语义）的角度把它和前面几个关键字归类到一起。

**extern 是 Previous Linkage 的**：准确地说 extern 应该是 Previous Linkage。Previous Linkage 的定义是：`这次声明的标识符具有什么样的Linkage取决于前一次声明，这前一次声明具有相同的标识符名，而且必须是文件作用域的声明，如果在程序文件中找不到前一次声明（这次声明是第一次声明），那么这个标识符具有External Linkage`。例如在一个程序文件中在文件作用域两次声明同一个函数：

```c
static int f(void); /* internal linkage */
//这里的extern修饰的标识符具有Interanl Linkage而不是External Linkage。
extern int f(void); /* previous linkage */
```

---
## 2 存储类别与函数

函数也有存储类别：

- 外部函数(默认)
- 静态函数
- 内联函数(C99)

```c
double gamma(double);//该函数为外部函数
static doble beta(int,int);//该函数为静态函数
extern double delte(double,int);//用extern来声明定义在其他文件的函数
```

---
## 3 存储类别选择

存储类别选择：优先使用自动存储类别。不要轻易定义共享变量，以防止该变量被篡改，唯一例外的是const数据。因为它们在初始化以后不会被修改。**定义变量的法则：**按需知道，尽量在函数内部解决所有任务，只共享那些需要共享的变量

---
## 4 ANSI C 类型限定符（Type Qualifier）

通常用类型(比如 int )和存储类别(比如 auto)来描述一个变量。

- C90 新增了两个属性：恒常性和易变性
  - 恒常性，对应 const 关键字，const 用于定义常量
  - 易变性，对应 volatile 关键字，告诉编译器该变量处理可以被程序修改外，还可以被其他代理修改，即使在编译时指定了优化选项，每次读这个变量仍然要老老实实从内存读取，每次写这个变量也仍然要老老实实写回内存，不能省略任何步骤。
- C99 新增了第三个限定符：`restrict`用于提高编译器优化。
- C11 新增了第四个限定符：`_Atomic`

### volatile 限定符作用

volatile 限定符告知计算机，代理（而不是变量所在的程序）可以改变该变量的值。通常，它被用于硬件地址以及在其他程序或同时运行的线程中共享数据。

参考下面代码

```c
vall =x;
/* 一些不使用 x 的代码*/
val2　=　x
```

编译器会注意到以上代码使用了两次 x，但并未改变它的值。于是编译器把 x 的值临时储存在寄存器中，然后在 val2 需要使用 x 时，才从寄存器中（而不是从原始内存位置上）读取 x 的值，以节约时间。这个过程被称为高速缓存（caching）。通常，高速缓存是个不错的优化方案，但是如果一些其他代理在以上两条语句之间改变了x的值，就不能这样优化了。如果声明中没有 volatile 关键字，编译器会假定变量的值在使用过程中不变，然后再尝试优化代码。

可以同时用 const 和 volatile 限定一个值。例如，通常用 const 把硬件时钟设置为程序不能更改的变量，但是可以通过代理改变，这时用 volatile。只能在声明中同时使用这两个限定符。

### restrict 限定符作用

restrict 关键字允许编译器优化某部分代码以更好地支持计算。它只能用于指针，表明该指针是访问数据对象的唯一且初始的方式。

什么是数据对象的唯一且初始的方式？

```c
int ar[10];
// 指针restar是访问由malloc()所分配内存的唯一且初始的方式。因此，可以用restrict关键字限定它。
int * restrict restar = (int *) malloc(10 * sizeof(int));
// 指针par既不是访问ar数组中数据的初始方式，也不是唯一方式。所以不用把它设置为restrict。
int * par = ar;
```

**针对 restrict 的优化**：

```c
for　(int n　=　0;　n　<　10;　n++){
    par[n]　+=　5;
    restar[n]　+=　5;
    ar[n] *= 2;
    par[n]　+=　3;
    restar[n]　+=　3;
}
```

- 由于之前声明了 restar 是访问它所指向的数据块的唯一且初始的方式，编译器可以把涉及 restar的两条语句替换成 `restar[n] += 8;`。 /可以进行替换，不会导致程序错误。
- 如果把与par相关的两条语句替换成下面的语句，将导致计算错误：`par[n] += 8;`。因为for循环在par两次访问相同的数据之间，用ar改变了该数据的值。
- 如果未使用restrict关键字，编译器就必须假设最坏的情况（即，在两次使用指针之间，其他的标识符可能已经改变了数据）。如果用了restrict关键字，编译器就可以选择捷径优化计算。

**restrict 限定符还可用于函数形参中的指针**：这意味着编译器可以假定在函数体内其他标识符不会修改该指针指向的数据，而且编译器可以尝试对其优化，使其不做别的用途。例如，C 库有两个函数用于把一个位置上的字节拷贝到另一个位置。在C99中，这两个函数的原型是：

```c
//这两个函数都从位置s2把n字节拷贝到位置s1

//memcpy()函数要求两个位置不重叠，声明s1和s2为restrict说明这两个指针都是访问相应数据的唯一方式，所以它们不能访问相同块的数据。这满足了memcpy()无重叠的要求。
void * memcpy(void * restrict s1, const void * restrict s2, size_t n);

//memmove()函数允许重叠，它在拷贝数据时不得不更小心，以防在使用数据之前就先覆盖了数据。
void * memmove(void * s1, const void * s2, size_t n);
```

**restrict 关键字有两个读者**。

- 一个是编译器，该关键字告知编译器可以自由假定一些优化方案。
- 另一个读者是用户，该关键字告知用户要使用满足restrict要求的参数。总而言之，编译器不会检查用户是否遵循这一限制，但是无视它后果自负。

### _Atomic 类型限定符（C11）作用

`_Atomic` 类型限定符用于并发程序设计，C11通过包含可选的头文件`stdatomic.h`和`threads.h`，提供了一些可选的（不是必须实现的）管理方法，当一个线程对一个原子类型的对象执行原子操作时，其他线程不能访问该对象。

```c
//普通变量
int hogs;// 普通声明
hogs = 12;// 普通赋值

//原子变量
_Atomic int hogs;// hogs 是一个原子类型的变量
atomic_store(&hogs, 12); // stdatomic.h中的宏
```

在 hogs 中储存 12 是一个原子过程，其他线程不能访问 hogs。编写这种代码的前提是，编译器要支持这一新特性。
