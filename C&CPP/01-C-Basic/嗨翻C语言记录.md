# Head First C-《嗨翻C语言》阅读记录

## 1 C语言入门：进入 C 语言的世界

- C 语言旨在创建空间小、速度快的程序。它比其他大多数语言的抽象层次更低，也就是说用 C 语言写的代码更加接近机器语言。
- 计算机只理解一种语言——机器代码，即一串二进制0、1流。你可以在编译器的帮助下将C代码转化为机器代码。
- 为了写出速度快、空间小、可移植性高的程序，人们常使用 C 语言。绝大多数的操作系统、其他计算机语言和大多数游戏软件都是用C语言写的。

### main 函数

- C 语言是一种很小的语言，如果不使用外部库，它几乎什么也干不了。为了告诉编译器程序要使用哪些外部代码，需要包含（include）相关库的头文件。`stdio.h` 是最常见的头文件，stdio 库中包含了那些能在终端读写数据的代码。
- 所有的 C 代码都在函数中运行。对任何 C程序来讲，最重要的函数是`main()`函数。`main()`函数是程序中所有代码的起点。计算机会从`main()`函数开始运行程序。它的名字很重要：如果没有一个叫`main()`的函数，程序就无法启动。
- `main()`函数的返回类型是int。这是什么意思呢？当计算机在运行程序时，它需要一些方法来判断程序是否运行成功，计算机正是通过检查`main()`函数的返回值来做到这一点。如果让`main()`函数返回0，就表明程序运行成功；如果让它返回其他值，就表示程序在运行时出了问题。
- 在早期的 ANSI C 标准中，`main()`函数可以是void 类型。但是在 C99 标准中 main 函数的返回类型必须是 int。
- 如果想检查程序的退出状态，可以在 Windows 命令提示符中输入：`echo %ErrorLevel%`或在 Linux 或 Mac 终端中输入：`echo $?`
- `main()`这一函数的返回类型是 int，因此必须在函数结束前包含一条 return语句。即使不加，代码也能编译通过，但会收到编译器的警告。支持 C99 标准的编译器会在你忘记的时候插入一条 return 语句。如果你想让编译器遵循 C99 标准，可以使用`-std=99`选项。

### 运行程序

- C 语言是一种编译型语言，也就是说计算机不会直接解释代码，而是需要将给人阅读的源代码转化（或编译）为机器能够理解的机器代码，这样计算机才能够执行。
- 为了编译代码，需要一个叫编译器的程序。GNU 编译器套件（GNU  Compiler  Collection），也叫gcc，是最流行的C编译器之一。gcc 可以在很多操作系统中使用，而且除了C语言，它还可以编译很多其他语言，最重要的是，它是完全免费的。
- 在大部分机器中，可以用下面这个技巧来编译并运行代码：`gcc zork.c -o zork && ./zork`(在 Windows 中，应该输入 zork 而不是 ./zork)，这条命令只有在编译成功的情况下才会运行新程序，一旦编译过程中出了问题，它就会跳过运行程序这一步，仅仅在屏幕上显示错误消息。
- 为什么我在 Linux 和 Mac 中运行程序时必须在程序前加上`./`？因为在类 Unix 操作系统中，运行程序必须指定程序所在的目录，除非程序的目录已经列在了 PATH 环境变量中。

### C语言字符串

- C 语言不支持现成的字符串
- C 语言比其他大多数语言的抽象层次更低，因此它不提供字符串，而是用了相似的东西来代替：以字符为元素的数组。
- 字符串只是字符数组，当C语言看到一个这样的字符串时：`s = "Shatner"`，会把它当做一个数组读取，而这个数组是由一个个独立的字符组成的：`s = {'S', 'h', 'a', 't', 'n', 'e', 'r'}`。
- **哨兵字符**：C语言比大多数语言更低层，它无法确切地知道数组有多长，如果 C 语言想在屏幕上显示字符串，它就需要知道什么时候会到达字符数组的尾部，为此C语言加入了哨兵字符。哨兵字符是一个出现在字符串末尾的附加字符，它的值为 `\0`。每当计算机需要读取字符串的内容时，它会逐一扫描字符数组中的所有元素，直到碰到`\0`。
- `s = "Shatner"` 存储器中实际保存的是：`{'S', 'h', 'a', 't', 'n', 'e', 'r', '\0'}`。
- 为什么要设立哨兵字符？难道计算机就不知道字符串的长度吗？通常不知道。记录数组的长度不是C语言的强项，虽然编译器有时可以通过分析代码计算出数组的长度，但一般情况下，C 语言希望你来记录数组的长度，字符串其实就是个数组。
- 通常应该用双引号来定义字符串。用双引号定义的字符串叫字符串字面值（string  literal），比起字符数组，它输入起来也更方便。
- 字符串字面值和字符数组有没有区别？只有一个区别：字符串字面值是常量。也就是说这些字符一旦创建完毕，就不能再修改它们。如果修改它们就会遇到错误，具体什么错误取决于编译器，gcc 通常会显示总线错误（bus error）。
- **总线错误**：C语言采取不同的方式在存储器中保存字符串字面值。总线错误意味着程序无法更新那一块存储器空间。

### switch

- 我能在 switch 语句中检查字符串吗？不能用 switch 语句检查字符串或任何形式的数组，switch 语句只能检查值。

## 2 存储器和指针

如果真的想玩转C语言，就需要理解C语言如何操纵存储器。

### 指针

- 指针是理解C语言最基本的要素之一。那么什么是指针？指针就是存储器中某条数据的地址。
- 在C语言中使用指针有以下几个原因：
  - 在函数调用时，可以只传递一个指针，而不用传递整份数据。
  - 让两段代码处理同一条数据，而不是处理两份独立的副本。
- 指针就做了两件事：避免副本和共享数据。

### 深入挖掘存储器

- 每当声明一个变量，计算机都会在存储器中某个地方为它创建空间。如果在函数（例如main()函数）中声明变量，计算机会把它保存在一个叫栈（Stack）的存储器区段中。
- 在函数以外的地方声明变量，计算机则会把它保存在存储器的全局量段（Globals）。
- 变量的地址告诉你去哪里找存储器中的变量，这就是为什么地址有时也叫指针，因为它指向了存储器中的变量。
- 为什么局部变量保存在栈里，而全局变量保存在其他地方？局部变量和全局变量的用法不同。你永远只能得到一份全局变量，但如果写了一个调用自己的函数，就会得到同一个局部变量的很多个实例。
- 指针是真实的地址单元，还是某种形式的引用？它们是进程存储器中真实编号的地址。
- 为什么存储器是进程的？计算机会为每个进程分配一个简版存储器，看起来就像是一长串字节。实际的存储器复杂多了，但细节对进程隐藏了起来，这样操作系统就可以在存储器中移动进程，或释放并重新加载到其他位置。（MMU 负责虚拟内存和实际内存地址映射）
- 物理存储器：物理存储器的结构十分复杂，计算机通常会将存储器地址分组映射到存储芯片的不同的存储体（memory bank）。对大部分程序来说，不需要关心机器组织存储器的细节。
- 引用与指针：人们有时会把指针叫做“引用”，因为它引用了存储器中的某个地址单元。但C++程序员通常用“引用”表示C++中一个稍有不同的概念。

### 指针与数组

- 当你创建了一个数组，数组变量就可以当作指针使用，它指向数组在存储器中的起始地址。
- 对于 `char quote[] = "Cookies make you fat";`，计算机会为字符串的每一个字符以及结束字符`\0`在栈上分配空间，并把首字符的地址和 quote 变量关联起来，代码中只要出现这个 quote 变量，计算机就会把它替换成字符串首字符的地址。其实，数组变量就好比一个指针。
- 给函数参数组类型参数时，其实传给函数的是指针。即把数组变量传给指针，会发生退化。
- sizeof(指针)在 32 位操作系统中返回 4，在 64 位操作系统中返回 8。在 32 位操作系统中，存储器地址以32位数字的形式保存，所以它叫 32 位操作系统。32 位==4 字节，所以 64 位操作系统要用 8 个字节来保存地址。
- 运算符：编译器会把运算符编译为一串指令；而当程序调用函数时，会跳到一段独立的代码中执行。
- 程序是在编译期间计算 sizeof 的，编译器可以在编译时确定存储空间的大小。
- 数组变量可以用作指针，这个指针指向数组的第一个元素，也就是说除了方括号表示法，还可以用`*`运算符读取数组的第一个元素。
- 索引的本质是指针算术运算，所以数组从 0 开始。假设 drinks 是一个数组，则表达式 `drinks[i]` 和 `*(drinks + i)` 是等价的。

### 数组变量与指针不完全相同

```c
char s[] = "How big is it?";
char *t = s;
```

- sizeof（数组）是数组的大小。
- 指针变量是一个用来保存存储器地址的变量，那数组变量呢？如果对数组变量使用&运算符，结果是数组变量本身。
- 当程序员写下`&s`时，表示“数组s的地址是？”，数组s的地址就是 `s`；但如果他写的是`&t`，则表示“变量t的地址是？”。
- **数组变量不能指向其他地方**：当创建指针变量时，计算机会为它分配4或8字节的存储空间。但如果创建的是数组呢？计算机会为数组分配存储空间，但不会为数组变量分配任何空间，编译器仅在出现它的地方把它替换成数组的起始地址。但是由于计算机没有为数组变量分配空间，也就不能把它指向其他地方。`s = t;`会导致编译错误。
- 为什么数组变量不保存在存储器中？既然它存在，就应该在某个地方，不是吗？程序在编译期间，会把所有对数组变量的引用替换成数组的地址。也就是说在最后的可执行文件中，数组变量并不存在。既然数组变量从来不需要指向其他地方，有和没有其实都一样。

### 指针有类型

为什么指针有类型？指针变量具有类型，这样就能调整指针算术运算。

- 如果对char指针加1，指针会指向存储器中下一个地址，那是因为char就占1字节。
- 如果是int指针呢？int通常占4字节，如果对int指针加1，编译后的代码就会对存储器地址加4。
- C语言什么时候对指针算术运算进行调整？在编译器生成可执行文件时，编译器会根据变量的类型，用变量的大小乘以指针的增量或减量。假如编译器看到你对一个指向int数组的指针加2，就会用2乘以4（int的长度），然后对地址加8。

```c
int doses[] = {1, 3, 2, 1000};
//doses[3] == *(doses + 3) == *(3 + doses) == 3[doses]
printf("服用 %i 毫克的药", 3[doses]);
```

### 用指针输入数据：scanf 和 fgets

```c
//scanf
char name[40];
printf("Enter your name: ");
scanf("%39s", name);

//scanf
char first_name[20];
char last_name[20];
printf("Enter first and last name: ");
scanf("%19s %19s", first_name, last_name);
printf("First: %s Last:%s\n", first_name, last_name);
```

- scanf()其实表示“scan formatted”，它用来扫描带格式的输入。
- **`scanf()`可能导致溢出**：如果忘了限制`scanf()`读取字符串的长度，用户就可以输入远远超出程序空间的数据，多余的数据会写到计算机还没有分配好的存储器中。如果运气好，数据不但能保存，而且不会有任何问题。但缓冲区溢出很有可能会导致程序出错，这种情况通常被称为段错误 或 abort trap，不管出现什么错误消息，程序都会崩溃。

```c
char food[5];
printf("Enter favorite food: ");
fgets(food, sizeof(food), stdin);
```

- 调用`fgets()`时不可能一不小心忘记设置长度，因为它就出现在了函数的签名中，所以不得不加这个参数。另外，注意`fgets()`缓冲区大小把`\0`字符也算了进去，所以不必像`scanf()`那样把长度减1。
- `fgets()`函数其实是从一个更古老的函数演变而来的，它叫`gets()`。尽管我们说`fgets()`比`scanf()`更加安全，但它的祖先`gets()`才是最危险的。为什么？因为`gets()`函数没有任何限制。

```c
char dangerous[10];
gets(dangerous);
```

scanf 和 fgets 对比：

- 限制用户输入的字符数吗？
  - `scanf()` 只要记得在格式串中加入长度，`scanf()` 就能限制用户输入数据的长度。
  - `fgets()` 强行限制用户输入字符串的长度，可谓无懈可击。
- 能输入多个字段吗？
  - `scanf()`不但允许输入多个字段，而且允许输入结构化数据，可以指定两个字段之间以什么字符分割。
  - `fgets()`只允许向缓冲区中输入一个字符串，而且只能是字符串，不能是其他数据类型，只能有一个缓冲区。
- 用户能输入带空格的字符串吗？
  - 当`scanf()`用`%s`读取字符串时，遇到空格就会停止。如果想要输入多个单词，需要多次调用`scanf()`，或使用一些复杂的正则表达式技巧。
  - 无论何时，`fgets()`都能读取整个字符串。

### 字符串字面值不能更新

这是由C语言使用存储器的方式决定的

```c
//不能用这个变量修改这个字符串。
char *cards = "JQK";
// 但如果你用字符串字面值创建一个数组，就可以修改了：
char cards[] = "JQK";
```

对于存储器中的`char *cards=“JQK”;`：

- 计算机加载字符串字面值：当计算机把程序载入存储器时，会把所有常数值（如字符串常量“JQK”）放到常量存储区，这部分存储器是只读的。
- 程序在栈上创建cards变量：栈是存储器中计算机用来保存局部变量的部分，局部变量也就是位于函数内部的变量，cards变量就在这个地方。
- cards变量设为“JQK”的地址：cards变量将会保存字符串字面值“JQK”的地址。为了防止修改，字符串字面值通常保存在只读存储器中。
- 计算机试图修改字符串：程序试图修改cards变量指向的字符串中的内容时就会失败，因为字符串是只读的。
- 如果想修改字符串，就复制它。

对于存储器中的`char cards[]=“JQK”;`：

- 计算机载入字符串字面值：和刚刚一样，当计算机把程序载入存储器时，会把常量值（如字符串“JQK”）保存到只读存储器。
- 程序在栈上新建了一个数组：我们声明了数组，所以程序会创建一个足够大的数组来保存字符串 “JQK”，在这个例子中 4 个字符足矣。
- 程序初始化数组：除了为数组分配空间，程序还会把字符串字面值 “JQK” 的内容复制到栈上。

`const char *`：

- 可以将 char 指针声明成为`const char  *`，以防代码用它修改字符串。
- 其实加不加 const，字符串字面值都是只读的，const 修饰符表示，一旦你试图用 const 修饰过的变量去修改数组，编译器就会报错。

### 声明与定义

声明是一段代码，它声称某样东西（变量或函数）存在。定义说明它是什么东西。如果在声明了变量的同时将其设为某个值（例如int x = 4;），这段代码既是声明又是定义。

### 存储器区域

- 栈：这是存储器用来保存局部变量的部分。每当调用函数，函数的所有局部变量都在栈上创建。它之所以叫栈是因为它看起来就像堆积而成的栈板：当进入函数时，变量会放到栈顶；离开函数时，把变量从栈顶拿走。奇怪的是，栈做起事来颠三倒四，它从存储器的顶部开始，向下增长。
- 堆：堆用于动态存储：程序在运行时创建一些数据，然后使用很长一段时间。
- 全局量：全局量位于所有函数之外，并对所有函数可见。程序一开始运行时就会创建全局量。
- 常量：常量也在程序一开始运行时创建，但它们保存在只读存储器中。常量是一些在程序中要用到的不变量。
- 代码：很多操作系统都把代码放在存储器地址的低位。代码段也是只读的，它是存储器中用来加载机器代码的部分。

### string.h

- `string.h`是C标准库的一员，它负责处理字符串。如果想要连接、比较或复制字符串，`string.h` 中的函数就可以派上用场了。
- 如果使用到 string.h 中的函数，但忘了包含 string.h 这样的头文件会怎么样？对于某些头文件来说，编译器会给出一个警告，但最后还是会包含它们；但对另一些来讲，编译器会直接提示编译错误。

## 3 创建小工具

有一种小工具叫过滤器（filter），它逐行读取数据，对数据进行处理，再把数据写到某个地方。如果你的计算机是Unix，或你在Windows上安装了Cygwin，就已经拥有很多过滤器工具了。head：显示文件前几行的内容。tail：显示文件最后几行的内容。sed：流编辑器（stream editor），用来搜索和替换文本。

### 标准输入输出和重定向

- 操作系统控制数据如何进出标准输入、标准输出。如果在命令提示符或终端运行程序，操作系统会把所有键盘输入都发送到标准输入；默认情况下，如果操作系统从标准输出中读到数据，就发送到显示器。
- `scanf()`和`printf()`函数并不知道数据从哪里来，也不知道数据要到哪里去，它们也不关心这点，它们只管从标准输入读数据，向标准输出写数据。
- 操作系统为什么要使用标准输入、标准输出与程序交互呢？有一个很好的原因：因为这么一来，就可以重定向标准输入、标准输出，让程序从键盘以外的地方读数据、往显示器以外的地方写数据，例如文件。
- 用 `<` 重定向标准输入，用 `>` 重定向标准输出。
- `./geo2json < gpsdata.csv`：`<` 操作符告诉操作系统，程序的标准输入应该与 gpsdata.csv 文件相连，而不是键盘，所以可以把数据从文件发送到程序。现在只需重定向程序的输出。
- `./geo2json < gpsdata.csv > output.json`：`<` 操作符告诉操作系统，程序的标准输出应该与 output.json 文件相连，而不是屏幕。

### 用管道连接输入与输出

```bash
(./a.out | ./b.out) < test.cvs > output.josn
./a.out < test.cvs | b.out  > output.josn
```

- `(./a.out | ./b.out)`：当把两个程序连在一起，就可以把它们看成一个程序。
- `|`：管道连接两个进程，不同操作系统实现管道的方法不同，可能用存储器，也可能用临时文件。我们只要知道它从一端接收数据，在另一端发送数据就行了。
- 如果两个程序用管道相连，第二个程序要不要等第一个程序执行完后才能开始运行？不需要，两个程序可以同时运行，第一个程序一发出数据，第二个程序马上就可以处理。
- 我能用管道连接多个程序吗？能啊，只要在每个程序前加上一个|就行了，一连串相连的进程就叫流水线（pipeline）。
- 当我用管道连接多个进程时，< 与 > 分别重定向哪个进程的标准输入、哪个进程的标准输出？ < 会把文件内容发送到流水线中第一个进程的标准输入， > 会捕获流水线中最后一个进程的标准输出。

### 创建自己的数据流

- 程序运行时，操作系统会为它创建三条数据流：标准输入、标准输出和标准错误。但有时你需要创建自己的数据流。好在操作系统没有规定只能使用它分配的三条数据流，你可以在程序运行时创建自己的数据流。
- 每条数据流用一个指向文件的指针来表示，可以用`fopen()`函数创建新数据流。`fopen()`函数接收两个参数：文件名和模式。共有三种模式，分别是`w`（写文件）、`r`（读文件）与`a`（在文件末尾追加数据）。
- 当用完数据流，别忘了关闭它。虽然所有的数据流在程序结束后都会自动关闭，但你仍应该自己关闭它们这取决于操作系统。通常情况下，一个进程最多可以有256条数据流。但请记住，数据流的数量是有限的，用完后应该关闭它们

### `getopt()`

十个程序有九个需要选项。聊天程序有“系统设置”，游戏有调整难度的选项，而命令行工具需要有命令行选项。命令行选项是一些小开关，它们经常出现在命令行工具中。很多程序都会使用命令行选项，因此有一个专门的库函数，可以用它来简化处理过程。这个库函数叫`getopt()`，每一次调用都会返回命令行中下一个参数。

具体参考[使用getopt() 进行命令行处理 - IBM](https://www.ibm.com/developerworks/cn/aix/library/au-unix-getopt.html)。

## 4 使用多个源文件

### 简明数据类型指南

- char 字符在计算机的存储器中以字符编码的形式保存，字符编码是一个数字，因此在计算机看来，A与数字65完全一样。
- int 如果你要保存一个整数，通常可以使用int。不同计算机中int的大小不同，但至少应该有16位。一般而言，int可以保存几万以内的数字。
- short 但有时你想节省一点空间，毕竟如果只想保存一个几百、几千的数字，何必用int？可以用short，short通常只有int的一半大小。
- long 如果想保存一个很大的计数呢？long数据类型就是为此而生的。在某些计算机中，long的大小是int的两倍，所以可以保存几十亿以内的数字；但大部分计算机的long和int一样大，因为在这些计算机中int本身就很大。long至少应该有32位。
- float 是保存浮点数的基本数据类型。平时你会碰到很多浮点数，比如一杯香橙摩卡冰乐有多少毫升，就可以用float保存。
- 如果想表示很精确的浮点数呢？如果想让计算结果精确到小数点以后很多位，可以使用double。double比float多占一倍空间，可以保存更大、更精确的数字。
- 赋值时要保证值的类型与保存它的变量类型相匹配。不同数据类型的大小不同，千万别让值的大小超过变量。

unsigned 和 long

- 用 unsigned 修饰的数值只能是非负数。由于无需记录负数，无符号数有更多的位可以使用，因此它可以保存更大的数。unsigned int 可以保存0到最大值的数。这个最大值是int可以保存最大值的两倍左右。还有signed关键字，但你几乎从没见过，因为所有数据类型默认都是有符号的。
- 你可以在数据类型前加 long，让它变长。long int 是加长版的 int；long int 可以保存范围更广的数字；long long 比 long 更长；还可以对浮点数用 long。

操作系统与数据类型

- 为什么不同操作系统的数据类型大小不同？设成一样不是更明了？为了适应硬件，C语言在不同的操作系统与处理器上使用不同的数据类型大小。C语言诞生之初还是8位机的天下，但现在大部分计算机都是32位和64位的，因为C语言没有指定数据类型的具体大小，所以才能与时俱进。即使新的计算机出来，C语言还是能够很好地适应。
- 8位、64位到底是什么意思？从技术上讲，计算机的位数有多种含义，它既可以代表CPU指令的长度，也可以代表CPU一次从存储器读取数据的大小。实际上，**位数是计算机能够处理的数值长度**。
- 如果一台计算机能处理 32 位的数值，就会把基本数据类型（例如int）的大小设为 32 位。

### 头文件、预处理

- 当编译器在代码中读到 `#include`，就会读取头文件中的内容，仿佛它们本来就在代码中。
- 为什么编译器需要预处理？严格意义上讲，编译器只完成编译的步骤，即把C源代码转化为汇编语言。但宽泛地讲，编译是将C源代码转化为可执行文件的整个过程，这个过程由很多阶段组成，而gcc允许你控制这些阶段。gcc会预处理和编译代码。
- 预处理是把C源代码转化为可执行文件的第一个阶段。预处理会在正式编译开始之前修改代码，创建一个新的源文件。拿你的代码来说，预处理会读取头文件中的内容，插入主文件。
- 预处理器会真的创建一个文件吗？不会，为了提高编译的效率，编译器通常会用管道在两个阶段之间发送数据。
- 编译器在寻找头文件时会查找哪些目录？gcc知道标准库的头文件被保存在哪里，在类 Unix 操作系统中，头文件通常保存在`/usr/local/include`、`/usr/include`这些地方。比如 gcc 找 stdio.h，在类 Unix 操作系统中，stdio.h位于/usr/include/stdio.h；如果在Windows中安装了MinGW编译器，stdio.h就很有可能在C:\MinGW\include\stdio.h中。

### 编译的幕后花絮

- 预处理：修改代码。编译器要做的第一件事就是修改代码。编译器需要用`#include`指令添加相关头文件；编译器可能还需要跳过程序中的某些代码，或补充一些代码。改完以后就可以随时编译源代码了。
- 编译：转换成汇编代码。C 语言看似底层，但计算机还是无法理解它。计算机只理解更低层的机器代码指令。而生成机器代码的第一步就是把 C 语言源代码转化为汇编语言代码。
- 汇编：生成目标代码。编译器需要将这些符号代码汇编成机器代码或目标代码，即 CPU 内部电路执行的二进制代码。
- 链接：放在一起。一旦有了全部的目标代码，就需要像拼“七巧板”那样把它们拼在一起，构成可执行程序。当某个目标代码的代码调用了另一个目标代码的函数时，编译器会把它们连接在一起。同时，链接还会确保程序能够调用库代码。最后，程序会写到一个可执行程序文件中，文件格式视操作系统而定，操作系统会根据文件格式把程序加载到存储器中运行。

### 用make工具自动化构建

make是一个可以替你运行编译命令的工具。make会检查源文件和目标文件的时间戳，如果目标文件过期，make就会重新编译它。但是做到所有这些事情前，需要告诉make源代码的一些情况。make需要知道文件之间的依赖关系，同时还需要告诉它你具体想如何构建代码。
