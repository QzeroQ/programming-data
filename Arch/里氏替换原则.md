# 里氏替换原则-Liskov Substitution Principle

里氏替换原则(Liskov Substitution Principle)：**所有引用基类的地方都能透明的使用其子类对象，通俗点讲就是只要父类出现的地方，都能用子类替换，而且不会产生任何错误和异常**

面向对象的三大特性，**封装，继承，多态**，而里氏替换原则依赖的就是继承和多态两大特性，类与类之间的继承则产生了超类和子类，超类是对子类的抽象，而子类类型既可以使用具体的引用也可以使用超类来引用，这就是同一事务的多种形态，在需要调用类的功能的地方，尽量使用超类引用，而在具体运行的时候，抽象的声明可以使用各种具体的子类实现。从而可以让程序变得灵活与健壮。

里氏替换原则的核心原理是抽象，而抽象有又依赖于继承这个特性。

继承有如下特性：

*   子类必须完全实现父类方法
*   子类可以有自己的个性
*   覆盖或实现父类方法时输入参数可以被放大(但是不能放小，**子类中方法的前置条件必须与超类中被复写的方法的前置条件相同或者更宽松**）
*   覆盖或实现父类的方法时输出结果可以被放小，(**子类复写父类的方法，方法的返回值可以比父类方法的返回值小**)
*   如果子类不能完全实现父类的方法，或者父类的某些方法在子类中发生了畸变，可以断开继承关系，改用依赖，组合等关系代替，如真枪与玩具枪的列子

**继承的好处和缺点**：

好处在于：

*   代码的可复用性提高，减速创建类的工作量
*   可扩展性提高，定义父类抽象，子类实现后，进行扩展

缺点：

*   继承是侵入性的，一旦集成父类，就必须拥有父类的方法和属性，
*   代码的灵活性受到父类的约束
*   增强了耦合性，一旦父类的方法或属性修改，必须考虑其对子类的影响

前面讲的ImageLoader中，由于缓存的实现可能根据业务的需求而各有不同，所以抽象出ImageCache来规范图片缓存的基本行为，而在具体的运行中ImageCache有可以被替换为各种具体的实现，如：MemoryCache，DiskCache，DoubleCahce，甚至用户可以自己实现自己的缓存，因为提供了setImageCache的方法实现ImageCache的注入，这就是很明显的里氏替换原则的体现，MemoryCache，DiskCache，DoubleCahce都实现了ImageCache，ImageCache是对具体缓存的抽象，具体缓存具有实际类型与超类类型的多种形态。
