# 依赖倒置原则-Dependence Inversion Principle

依赖倒置原则(Dependence Inversion Principle)：**1，高层模块不应该依赖其低层模块，两者都因该依赖其抽象；2，抽象不应该依赖细节；3，细节应该依赖抽象**。

在Java语言中，抽象即使接口或者抽象类，这两者是不能被直接抽象画的，细节就是实现类，实现了接口或者抽象类的方法就是细节，其特点就是可以被实例化；高层模块就是调用端，底层模块就是实现类，依赖倒置的原则在Java语言中的体现就是：**模块之间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或者抽象类产生的**，讲白了就是**面向接口编程，面向抽象编程**。

依赖倒置原则有如下要求：

* 模块之间的依赖通过抽象发生，实现类之间不应该直接发生依赖关系，其依赖还是通过接口与抽象类发生的
* 抽象类或者接口不应该依赖实现类
* 实现类依赖于接口与抽象类

**模块之间只需要定义相互的依赖接口就可以进行开发，从而实现并行开发，独立模块也可以进行独立测试,这一点是很重要的。**

一个模块依赖于另一个模块，或者一个类的功能的实现依赖于另外一个类，那么这时就发生了依赖关系，应该做到的是类与类之间的相互声明尽量使用抽象类或者接口，那么如何实现依赖的注入呢，即如何把具体的实现设置给声明的依赖呢？

## 注入依赖

* 构造函数传递对象
* 利用set方法传入依赖对象
* 接口声明依赖对象，也叫接口注入
* 注解注入

## 最佳实践

* 每个类都应该有其接口或者抽象，或者两者都有，**有了抽象才可以依赖倒置**
* 变量的表面类型尽量使其接口或者抽象
* 任何类都不应该从具体的类派生
* 尽量不覆写父类中已实现的方法，
* 结合里氏替换原则使用，结合里氏替换原则所得：接口负责定义public的属性和方法，并负责定义与其他对象的依赖关系，抽象类辅助公共部件(接口的框架实现)的实现，实现类准确的实现业务逻辑，同时适当的对父类进行细化

## 理清倒置与正置

依赖正置就是类与类之间的关系是实实在在的实现类，也就是面向实现编程，这符合人的正常思维，要开奔驰车就需要奔驰车，而编程确是对具体事务的抽象，有了接口与实现类就有了抽象与具体，然后根据业务定义相互之间的依赖关系。

## 实例 1

司机与汽车的例子，司机不仅仅可以驾驶宝马，而且可以驾驶很多车：

### 依赖于具体编程

具体的司机依赖具体的车子，司机依赖奔驰，这就造成了司机只能开奔驰车，完全无发并行开发，必须有了车子才能继续开发驾驶员!!!，而且司机只能驾驶奔驰车。

```java
public class Benz {

    public void run() {
        System.out.println("奔驰车子启动");
    }
}

public class Driver {

    public void driver(Benz benz) {
        benz.run();
    }
}

public class Client {
    public static void main(String[] args) {

        Driver driver = new Driver();
        driver.driver(new Benz());

    }
}
```

## 依赖于抽象编程

模块之间通过接口实现依赖，定义锲约即可以达到并行开发，其次Driver不在依赖于具体的奔驰，由于他依赖的是抽象，在具体的实现中，它可以开各种车子。这就给体统带来了灵活性。

```java
public interface ICar {

    void run();
}

public interface IDriver {

    void driver(ICar car);

}
```

## 实例 2

前面的ImageLoader中，首先ImageLoader依赖于具体的MemoryCache来实现图片的内存缓存，但是这样一来ImageLoader就有了很大的局限性，它只能依赖于MemoryCache，如果以后要实现其他的图片缓存，那么必须对ImageLoader进行改造，这样的设计就带来的系统的不稳定性，而通过抽象缓存行为，让ImageLoader依赖抽象的ImageCache接口，从而实现了图片缓存的灵活配置，也增强了这个框架的稳定性，从而不会因为一个小小需求增加而需要对原有的代码进行大的修改。
