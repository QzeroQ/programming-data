# 五、深入探究文件IO

## 1 原子操作和竞争条件，使用原子操作避免竞争条件

- **所有系统调用都是以原子操作方式执行的**：内核保证了某系统调用中的所有步骤会作为独立操作而一次性加以执行，其间不会为其他进程或线程所中断。
- **竞争条件**：操作共享资源的两个进程（或线程），其结果取决于一个无法预期的顺序，即这些进程获得 CPU 使用权的先后相对顺序。原子操作规避了竞争条件的产生。
- **涉及文件 I/O 的两种竞争状态**:
  - 以独占的方式创建一个文件：并发环境下，若想以独占的方式创建一个文件，调用 open 函数时创建文件，需要加上  `O_EXCL` 标志位。
  - 向文件尾部追加数据 ：多个进程同时向同一个文件（例如，全局日 志文件）尾部添加数据。为了避免静态条件的发生，应该在打开文件时加入 `O_APPEND`。

## 2 使用 `fcntl()` 修改打开文件的状态标志

`fcntl()` 系统调用用于对一个打开的文件描述符执行一系列控制操作，通过 fcntl 可以改变已打开的文件性质。fcntl 针对描述符提供控制。调用 `fcntl()` 时如果返回 `-1`，则说明调用发生错误。

- `fcntl()`的用途之一是针对一个打开的文件，获取或修改其访问模式和状态标志（这些值是通过指定 `open()` 调用的 flag 参数来设置的）。要获取这些设置，应将 `fcntl()` 的 cmd 参数设置为 `F_GETFL`。
- 使用 `fcntl()` 的 F_SETFL 命令可以修改打开文件的某些状态标志。允许更改的标志有 `O_APPEND、O_NONBLOCK、O_NOATIME、O_ASYNC 和 O_DIRECT`。系统将忽略对其他标志的修改操作。

## 3 文件描述符和打开文件之间的关系——多个文件描述符可以指向同一打开文件

**多个文件描述符可以指向同一打开文件，这些文件描述符可在相同或不同的进程中打开**。要理清文件描述符和打开文件之间的关系，需要掌握内核维护的 3 个数据结构。

- **进程级的文件描述符表**
- **系统级的打开文件表**
- **文件系统的 i-node 表**：

可能存在的关系：

- 同一个进程的不同文件描述符指向同一个文件句柄。
  - 原因：可能通过 `dup()`、`dup2()` 或 `fcntl()` 函数实现。
- 不同进程的相同文件描述符指向同一个文件句柄。
  - 原因：可能在调用 `fork()` 后出现，或某进程通过 UNIX 域套接字将一个打开的文件描述符传递给另一进程。
- 不同进程的不同文件描述符指向不同的文件句柄，但这些句柄均指向 i-node 表中的相同条目，即指向同一文件。
  - 原因：每个进程各自对同一文件发起了 `open()` 调用，同一个进程两次打开同一文件。

## 4 复制文件描述符

**相关操作**：

```shell
#通知shell把标准错误（文件描述符2）重定向到标准输出（文件描述符1）。
2>&1
```

为什么不是 `2>1` 呢，因为这样 shell 可能讲 1 当作一个文件，而非一个文件描述符，所以需要加上 & 来标识 1 是文件描述符。具体参考 [in-the-shell-what-does-21-mean](https://stackoverflow.com/questions/818255/in-the-shell-what-does-21-mean)

**相关函数**：

- `int dup(int oldfd);`
- `int dup2(int oldfd, int newfd);`
- `int fcntl(oldfd, F_DUPFD, startfd);`
- `int dup3(int oldfd, int newfd, int flags);`

## 5 读写功能的扩展

- **在文件特定偏移量处的 I/O：`pread()` 和 `pwrite()`**：系统调用 pread() 和 pwrite() 的功能与 read() 和 write() 类似，只是前两者会在 offset 参数所指定的位置进行文件 I/O 操作，而非始于文件的当前偏移量处，且它们不会改变文件的当前偏移量。
- **分散输入和集中输出（Scatter-Gather I/O） ：`readv()` 和 `writev()`**：这些系统调用并非只对单个缓冲区进行读写操作，而是一次即可传输多个缓冲区的数据。
- **截断文件：truncate()和 ftruncate()系统调用**：若文件当前长度大于参数 length，调用将丢弃超出部分，若小于参数 length，调用将在文 件尾部添加一系列空字节或是一个文件空洞。

`pread()` 和 `pwrite()` 以及`readv()` 和 `writev()` 都可用于防止某些竞态条件的产生。

## 6 非阻塞 I/O

- 调用 open 函数时，添加 O_NONBLOCK 标志位。
- 因为无法通过 `open()` 来获取管道和套接字的文件描述符，所以要启用非阻塞标志，就必须使用 `fcntl()` 的 F_SETFL 命令。

## 7 大文件 I/O

LFS API 用于支持对大文件的操作。

## 总结

**知识点**：

- 理解涉及文件 I/O 的两种竞争状态，掌握如何运用 open 函数提供的标志位来避免产生这些竞争状态。
- 掌握 fcntl 函数的基本功能。
- 掌握多进程下文件描述符和打开文件之间的关系。

**代码实践**：

todo
