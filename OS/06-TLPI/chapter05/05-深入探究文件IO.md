# 五、深入探究文件IO

## 1 原子操作和竞争条件，使用原子操作避免竞争条件

- **所有系统调用都是以原子操作方式执行的**：内核保证了某系统调用中的所有步骤会作为独立操作而一次性加以执行，其间不会为其他进程或线程所中断。
- **竞争条件**：操作共享资源的两个进程（或线程），其结果取决于一个无法预期的顺序，即这些进程获得 CPU 使用权的先后相对顺序。原子操作规避了竞争条件的产生。
- **涉及文件 I/O 的两种竞争状态**:
  - 以独占的方式创建一个文件：并发环境下，若想以独占的方式创建一个文件，调用 open 函数时创建文件，需要加上  `O_EXCL` 标志位。
  - 向文件尾部追加数据 ：多个进程同时向同一个文件（例如，全局日 志文件）尾部添加数据。为了避免静态条件的发生，应该在打开文件时加入 `O_APPEND`。

## 2 使用 `fcntl()` 修改打开文件的状态标志

`fcntl()` 系统调用用于对一个打开的文件描述符执行一系列控制操作，通过 `fcntl` 可以改变已打开的文件性质。`fcntl` 针对描述符提供控制。调用 `fcntl()` 时如果返回 `-1`，则说明调用发生错误。

- `fcntl()`的用途之一是针对一个打开的文件，获取或修改其访问模式和状态标志（这些值是通过指定 `open()` 调用的 flag 参数来设置的）。要获取这些设置，应将 `fcntl()` 的 cmd 参数设置为 `F_GETFL`。
- 使用 `fcntl()` 的 `F_SETFL` 命令可以修改打开文件的某些状态标志。允许更改的标志有 `O_APPEND、O_NONBLOCK、O_NOATIME、O_ASYNC 和 O_DIRECT`。系统将忽略对其他标志的修改操作。

## 3 文件描述符和打开文件之间的关系——多个文件描述符可以指向同一打开文件

**多个文件描述符可以指向同一打开文件，这些文件描述符可在相同或不同的进程中打开**。要理清文件描述符和打开文件之间的关系，需要掌握内核维护的 3 个数据结构。

- **进程级的文件描述符表**
- **系统级的打开文件表**
- **文件系统的 i-node 表**：

可能存在的关系：

- 同一个进程的不同文件描述符指向同一个文件句柄。
  - 原因：可能通过 `dup()`、`dup2()` 或 `fcntl()` 函数实现。
- 不同进程的相同文件描述符指向同一个文件句柄。
  - 原因：可能在调用 `fork()` 后出现，或某进程通过 UNIX 域套接字将一个打开的文件描述符传递给另一进程。
- 不同进程的不同文件描述符指向不同的文件句柄，但这些句柄均指向 i-node 表中的相同条目，即指向同一文件。
  - 原因：每个进程各自对同一文件发起了 `open()` 调用，同一个进程两次打开同一文件。

## 4 复制文件描述符

使用 shell：

```shell
#通知shell把标准错误（文件描述符2）重定向到标准输出（文件描述符1）。
2>&1
```

为什么不是 `2>1` 呢，因为这样 shell 可能讲 1 当作一个文件，而非一个文件描述符，所以需要加上 & 来标识 1 是文件描述符。具体参考 [in-the-shell-what-does-21-mean](https://stackoverflow.com/questions/818255/in-the-shell-what-does-21-mean)

使用函数：

- `int dup(int oldfd);`
- `int dup2(int oldfd, int newfd);`
- `int fcntl(oldfd, F_DUPFD, startfd);`
- `int dup3(int oldfd, int newfd, int flags);`

## 5 读写功能的扩展

- **在文件特定偏移量处的 I/O：`pread()` 和 `pwrite()`**：系统调用 `pread()` 和 `pwrite()` 的功能与 `read()1 和 1write()1 类似，只是前两者会在 offset 参数所指定的位置进行文件 I/O 操作，而非始于文件的当前偏移量处，且它们不会改变文件的当前偏移量。
- **分散输入和集中输出（Scatter-Gather I/O） ：`readv()` 和 `writev()`**：这些系统调用并非只对单个缓冲区进行读写操作，而是一次即可传输多个缓冲区的数据。
- **截断文件：`truncate()` 和 `ftruncate()` 系统调用**：若文件当前长度大于参数 length，调用将丢弃超出部分，若小于参数 length，调用将在文 件尾部添加一系列空字节或是一个文件空洞。

`pread()` 和 `pwrite()` 以及`readv()` 和 `writev()` 都可用于防止某些竞态条件的产生。

## 6 非阻塞 I/O

- 调用 open 函数时，添加 O_NONBLOCK 标志位。
- 因为无法通过 `open()` 来获取管道和套接字的文件描述符，所以要启用非阻塞标志，就必须使用 `fcntl()` 的 `F_SETFL` 命令。

## 7 大文件 I/O

LFS API 用于支持对大文件的操作。

## 8 `/dev/fd` 目录

- 对于每个进程，内核都提供有一个特殊的虚拟目录 `/dev/fd`。该目录中包含 `/dev/fd/n` 形式的文件名，其中n是与进程中的打开文件描述符相对应的编号。
- `/dev/fd` 实际上是一个符号链接，链接到 Linux 所专有的 `/proc/self/fd` 目录。后者又是 Linux 特有的 `/proc/PID/fd` 目录族的特例之一，此目录族中的每一目录都包含有符号链接，与一进程所打开的所有文件相对应。
- `/dev/fd/0`、`/dev/fd/1`、`/dev/fd/2` 分别对应标准输入、标准输出、标准错误输出。

`/dev/fd` 目录中的文件的其主要用途在 shell 中：

1. 许多用户级shell命令将文件名作为参数，有时需要将命令输出至管道，并将某个参数替换为标准输入或标准输出。
2. 出于这一目的，有些命令（例如，diff、ed、tar和comm）提供了一个解决方法，使用“-”符号作为命令的参数之一，用以表示标准输入或输出。
3. 比如 `ls | diff - oldfilelist` 命令用于比较 ls 命令输出的文件名列表与之前生成的文件名列表。`- oldfilelist`，这里的 `-` 就表示标准输出。
4. 存在的问题：
   1. 该方法要求每个程序都对“-”符号做专门处理，但是许多程序并未实现这样的功能，这些命令只能处理文件，不支持将标准输入或输出作为参数。
   2. 有些程序还将单个“-”符解释为表征命令行选项结束的分隔符。
5. 使用 `/dev/fd` 目录可以解决这个问题，`ls | diff - oldfilelist` 可以改写成 `ls | diff /def/fd/0 oldfilelist`。

## 9 创建零时文件

- `mkstemp()` 函数生成一个唯一文件名并打开该文件，返回一个可用于I/O调用的文件描述符。
- `tmpfile()`函数会创建一个名称唯一的临时文件，并以读写方式将其打开。
