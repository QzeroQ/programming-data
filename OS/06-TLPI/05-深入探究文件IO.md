# 五、深入探究文件IO

## 1 原子操作和竞争条件

- **所有系统调用都是以原子操作方式执行的**：内核保证了某系统调用中的所有步骤会作为独立操作而一次性加以执行，其间不会为其他进程或线程所中断。
- **竞争条件**：操作共享资源的两个进程（或线程），其结果取决于一个无法预期的顺序，即这些进程获得 CPU 使用权的先后相对顺序。原子操作规避了竞争条件的产生。
- **涉及文件 I/O 的两种竞争状态**:
  - 以独占的方式创建一个文件：并发环境下，若想以独占的方式创建一个文件，调用 open 函数时创建文件，需要加上  `O_EXCL` 标志位。
  - 向文件尾部追加数据 ：多个进程同时向同一个文件（例如，全局日 志文件）尾部添加数据。为了避免静态条件的发生，应该在打开文件时加入 `O_APPEND`。

## 2 使用 `fcntl()` 修改打开文件的状态标志

`fcntl()` 系统调用用于对一个打开的文件描述符执行一系列控制操作，通过 fcntl 可以改变已打开的文件性质。fcntl 针对描述符提供控制。调用 `fcntl()` 时如果返回 `-1`，则说明调用发生错误。

- `fcntl()`的用途之一是针对一个打开的文件，获取或修改其访问模式和状态标志（这些值是通过指定 `open()` 调用的 flag 参数来设置的）。要获取这些设置，应将 `fcntl()` 的 cmd 参数设置为 `F_GETFL`。
- 使用 `fcntl()` 的 F_SETFL 命令可以修改打开文件的某些状态标志。允许更改的标志有 `O_APPEND、O_NONBLOCK、O_NOATIME、O_ASYNC 和 O_DIRECT`。系统将忽略对其他标志的修改操作。

## 3 文件描述符和打开文件之间的关系

**多个文件描述符可以指向同一打开文件，这些文件描述符可在相同或不同的进程中打开**。

理清文件描述符和打开文件之间的关系，需要掌握内核维护的 3 个数据结构。

- **进程级的文件描述符表**：针对每个进程，内核为其维护打开文件的描述符（open file descriptor）表。该表的每一条目都记录了单个文件描述符的相关信息。
  - 控制文件描述符操作的一组标志（仅包含一个 close-on-exec 标志）。
  - 对打开文件句柄的引用。
- **系统级的打开文件表**：内核对所有打开的文件维护有一个系统级的描述表格（open file description table）。有时也称之为打开文件表（open file table），并将表中各条目称为打开文件句柄（open file handle）。
  - 当前文件偏移量（调用 read()和 write()时更新，或使用 lseek()直接修改）。
  - 打开文件时所使用的状态标志（即，open()的 flags 参数）。
  - 文件访问模式。
  - 与信号驱动 I/O 相关的设置。
  - 对该文件 i-node 对象的引用。
- **文件系统的 i-node 表**：每个文件系统都会为驻留其上的所有文件建立一个 i-node 表。
  - 文件类型（例如，常规文件、套接字或 FIFO）和访问权限。
  - 一个指针，指向该文件所持有的锁的列表。
  - 文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳。

## 4 复制文件描述符

**相关操作**：

```shell
#通知shell把标准错误（文件描述符2）重定向到标准输出（文件描述符1）。
2>&1
```

为什么不是 `2>1` 呢，因为这样 shell 可能讲 1 当作一个文件，而非一个文件描述符，所以需要加上 & 来标识 1 是文件描述符。具体参考 [in-the-shell-what-does-21-mean](https://stackoverflow.com/questions/818255/in-the-shell-what-does-21-mean)

**相关函数**：

```c
#include <unistd.h>

int dup(int oldfd);
```

`dup()`调用复制一个打开的文件描述符oldfd，并返回一个新描述符，二者都指向同一打开的文件句柄。系统会保证新描述符一定是编号值最低的未用文件描述符。dup 返回 -1 表示调用失败。

```c
#include <unistd.h>

int dup2(int oldfd, int newfd);
```

`dup2()`系统调用会为 oldfd 参数所指定的文件描述符创建副本，其编号由 newfd 参数指定。如果由 newfd 参数所指定编号的文件描述符之前已经打开，那么 `dup2()` 会首先将其关闭。（`dup2()`调用会默然忽略 newfd 关闭期间出现的任何错误。因此编码时更为安全的做法是在调用 `dup2()` 之前，若 newfd 已经打开，则应显式调用 `close()`将其关闭。）dup2 返回 -1 表示调用失败，若调用 `dup2()` 成功，则将返回副本的文件描述符编号。

```c
#include <unistd.h>

newfd = fcntl(oldfd, F_DUPFD, startfd);
```

`fcntl()`的 F_DUPFD 操作也是复制文件描述符，该调用为 oldfd 创建一个副本，且将使用大于等于 startfd 的最小未用值作为描述符编号。该调用还能保证新描述符（newfd）编号落在特定的区间范围内。

```c
#include <unistd.h>

int dup2(int oldfd, int newfd, int flags);
```

## 总结

**知识点**：

- 理解涉及文件 I/O 的两种竞争状态，掌握如何运用 open 函数提供的标志位来避免产生这些竞争状态。
- 掌握 fcntl 函数的基本功能。
- 掌握多进程下文件描述符和打开文件之间的关系。

**代码实践**：

todo
