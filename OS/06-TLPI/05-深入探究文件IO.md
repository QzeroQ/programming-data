# 五、深入探究文件IO

## 1 原子操作和竞争条件，使用原子操作避免竞争条件

- **所有系统调用都是以原子操作方式执行的**：内核保证了某系统调用中的所有步骤会作为独立操作而一次性加以执行，其间不会为其他进程或线程所中断。
- **竞争条件**：操作共享资源的两个进程（或线程），其结果取决于一个无法预期的顺序，即这些进程获得 CPU 使用权的先后相对顺序。原子操作规避了竞争条件的产生。
- **涉及文件 I/O 的两种竞争状态**:
  - 以独占的方式创建一个文件：并发环境下，若想以独占的方式创建一个文件，调用 open 函数时创建文件，需要加上  `O_EXCL` 标志位。
  - 向文件尾部追加数据 ：多个进程同时向同一个文件（例如，全局日 志文件）尾部添加数据。为了避免静态条件的发生，应该在打开文件时加入 `O_APPEND`。

## 2 使用 `fcntl()` 修改打开文件的状态标志

`fcntl()` 系统调用用于对一个打开的文件描述符执行一系列控制操作，通过 fcntl 可以改变已打开的文件性质。fcntl 针对描述符提供控制。调用 `fcntl()` 时如果返回 `-1`，则说明调用发生错误。

- `fcntl()`的用途之一是针对一个打开的文件，获取或修改其访问模式和状态标志（这些值是通过指定 `open()` 调用的 flag 参数来设置的）。要获取这些设置，应将 `fcntl()` 的 cmd 参数设置为 `F_GETFL`。
- 使用 `fcntl()` 的 F_SETFL 命令可以修改打开文件的某些状态标志。允许更改的标志有 `O_APPEND、O_NONBLOCK、O_NOATIME、O_ASYNC 和 O_DIRECT`。系统将忽略对其他标志的修改操作。

## 3 文件描述符和打开文件之间的关系——多个文件描述符可以指向同一打开文件

**多个文件描述符可以指向同一打开文件，这些文件描述符可在相同或不同的进程中打开**。

理清文件描述符和打开文件之间的关系，需要掌握内核维护的 3 个数据结构。

- **进程级的文件描述符表**：针对每个进程，内核为其维护打开文件的描述符（open file descriptor）表。该表的每一条目都记录了单个文件描述符的相关信息。
  - 控制文件描述符操作的一组标志（仅包含一个 close-on-exec 标志）。
  - 对打开文件句柄的引用。
- **系统级的打开文件表**：内核对所有打开的文件维护有一个系统级的描述表格（open file description table）。有时也称之为打开文件表（open file table），并将表中各条目称为打开文件句柄（open file handle）。
  - 当前文件偏移量（调用 read()和 write()时更新，或使用 lseek()直接修改）。
  - 打开文件时所使用的状态标志（即，open()的 flags 参数）。
  - 文件访问模式。
  - 与信号驱动 I/O 相关的设置。
  - 对该文件 i-node 对象的引用。
- **文件系统的 i-node 表**：每个文件系统都会为驻留其上的所有文件建立一个 i-node 表。
  - 文件类型（例如，常规文件、套接字或 FIFO）和访问权限。
  - 一个指针，指向该文件所持有的锁的列表。
  - 文件的各种属性，包括文件大小以及与不同类型操作相关的时间戳。

可能存在的关系：

- 同一个进程的不同文件描述符指向同一个文件句柄。原因：可能通过 dup()、dup2() 或 fcntl() 函数实现。
- 不同进程的相同文件描述符指向同一个文件句柄。原因：可能在调用 fork() 后出现，或某进程通过 UNIX 域套接字将一个打开的文件描述符传递给另一进程。
- 不同进程的不同文件描述符指向不同的文件句柄，但这些句柄均指向 i-node 表中的相同条目，即指向同一文件。原因：每个 进程各自对同一文件发起了 open()调用，同一个进程两次打开同一文件。

## 4 复制文件描述符

todo

## 总结

**知识点**：

- 理解涉及文件 I/O 的两种竞争状态，掌握如何运用 open 函数提供的标志位来避免产生这些竞争状态。
- 掌握 fcntl 函数的基本功能。
- 掌握多进程下文件描述符和打开文件之间的关系。

**代码实践**：

todo
