# 计算机指令

## 1 古老的编程方式：打孔卡

最古老的编程方式是打孔卡（Punched Card），当时的计算机或者说 CPU 本身，并没有能力理解这些高级语言。当时的编程方式是要先在脑海里或者在纸上写出程序，然后在纸带或者卡片上打洞。这样，要写的程序、要处理的数据，就变成一条条纸带或者一张张卡片，之后再交给当时的计算机去处理。

## 2 从软/硬件层面理解 CPU

- **硬件层面**：从硬件的角度来看，CPU 就是一个超大规模集成电路，通过电路实现了加法、乘法乃至各种各样的处理逻辑。
- **软件层面**：CPU 就是一个执行各种计算机指令（Instruction Code）的逻辑机器。

相关术语：

- **机器语言（Machine Language）**：计算机指令，就好比一门 CPU 能够听得懂的语言，也称为机器语言（Machine Language）。
- **计算机指令集**：即 CPU 所支持的指令的集合，英文叫 Instruction Set。不同的 CPU 能够听懂的语言不太一样。比如，我们的个人电脑用的是 Intel 的 CPU，苹果手机用的是 ARM 的 CPU。

程序指令的存储方式：

- **存储程序型计算机（Stored-program Computer）**：程序指令存储在存储器里面的计算机，比如如今的 PC、MAC、Android 设备、IPhone 等。
- **Plugboard Computer 的计算设备**：即插线板计算机，在一个布满了各种插口和插座的板子上，工程师们用不同的电线来连接不同的插口和插座，从而来完成各种计算任务。

## 3 代码怎么变成机器码

```c
// test.c
int main()
{
  int a = 1;
  int b = 2;
  a = a + b;
}
```

以上面一个简单的 C 语言程序为例，该程序需要经历`预处理、编译、汇编、链接`四个过程才能转变为可以运行的二进制程序。

- 编译过后的 C 程序就变成了汇编语言（ASM，Assembly Language）的程序。
- 针对汇编代码，我们可以再用汇编器（Assembler）翻译成机器码（Machine Code）。这些机器码由“0”和“1”组成的机器语言表示。这一条条机器码，就是一条条的计算机指令。这样一串串的 16 进制数字，就是我们 CPU 能够真正认识的计算机指令。

在一个 Linux 操作系统上，我们可以简单地使用 `gcc` 和 `objdump` 这样两条命令，把对应的汇编代码和机器码都打印出来。

```shell
gcc -g -c test.c
$ objdump -d -M intel -S test.o
```

除了 C 这样的编译型的语言之外，不管是 Python 这样的解释型语言，还是 Java 这样使用虚拟机的语言，其实最终都是由不同形式的程序，把我们写好的代码，转换成 CPU 能够理解的机器码来执行的。

## 4 指令和机器码

我们日常用的 Intel CPU，有 2000 条左右的 CPU 指令，可见计算机指令非常多，但常见的指令可以分成五大类。

- 第一类是算术类指令。我们的加减乘除，在 CPU 层面，都会变成一条条算术类指令。
- 第二类是数据传输类指令。给变量赋值、在内存里读写数据，用的都是数据传输类指令。
- 第三类是逻辑类指令。逻辑上的与或非，都是这一类指令。
- 第四类是条件分支类指令。日常我们写的“if/else”，其实都是条件分支类指令。
- 第五类是无条件跳转指令。写一些大一点的程序，我们常常需要写一些函数或者方法。在调用函数的时候，其实就是发起了一个无条件跳转指令。

这五类指令可以总结如下：

![05_instruction_sort](images/05_instruction_sort.jpeg)

### 机器码的计算方式

不同的 CPU 有不同的指令集，也就对应着不同的汇编语言和不同的机器码。以 MIPS 指令集为例，来看看机器码是如何生成的。

>MIPS 是一组由 MIPS 技术公司在 80 年代中期设计出来的 CPU 指令集。现在 MIPS 公司已经把整个指令集和芯片架构都完全开源了，具体可以参考 [MIPS](https://www.mips.com/mipsopen/)。

MIPS 的指令是一个 32 位的整数，分为两个部分：

- 高 6 位叫操作码（Opcode），也就是代表这条指令具体是一条什么样的指令。
- 剩下的 26 位有三种格式，分别是 R、I 和 J。

![05_mips](images/05_mips.jpeg)

- R 指令是一般用来做算术和逻辑操作，里面有读取和写入数据的寄存器的地址。如果是逻辑位移操作，后面还有位移操作的位移量，而最后的功能码，则是在前面的操作码不够的时候，扩展操作码表示对应的具体指令的。
- I 指令，则通常是用在数据传输、条件分支，以及在运算的时候使用的并非变量还是常数的时候。这个时候，没有了位移量和操作码，也没有了第三个寄存器，而是把这三部分直接合并成了一个地址值或者一个常数。
- J 指令就是一个跳转指令，高 6 位之外的 26 位都是一个跳转后的地址。

理解加法算术指令：`add t0,s1, $s2`：

- 加法对应的 MIPS 指令里 opcode 是 0。
- rs 代表第一个寄存器 s1 的地址是 17。
- rt 代表第二个寄存器 s2 的地址是 18。
- rd 代表目标的临时寄存器 t0 的地址，值为 8。
- shamt 代表位移量，因为不是位移操作，所以是 0。

把这些数字拼在一起，就变成了一个 MIPS 的加法指令。

![05_mips_add](images/05_mips_add.jpeg)

为了读起来方便，我们一般把对应的二进制数，用 16 进制表示出来。在这里，也就是 `0X02324020`。这个数字也就是这条指令对应的机器码。

>`0X02324020` 对应二进制 `0000 00/ 10 0011 0010 0100 0000 0010 0000‬`

## 5 学习资料

- 《计算机组成与设计：软/硬件接口》第 5 版的 2.17 小节介绍了 Intel CPU 的指令集。
- 关于 mips 指令中 funct 的含义，可以参考 [what-does-func-means-in-r-format-instruction-set](https://stackoverflow.com/questions/6929440/what-does-func-means-in-r-format-instruction-set)

## 6 思考

我们把一个数字在命令行里面打印出来，背后对应的机器码是什么？可以试试通过 GCC 把这个的汇编代码和机器码打出来。

```c
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char const *argv[])
{

  printf("%d\n", 123);

  return 0;
}
```

使用命令 `objdump -d -S a.out`：

```log
000000000000064a <main>:
 64a:   55                      push   %rbp
 64b:   48 89 e5                mov    %rsp,%rbp
 64e:   48 83 ec 10             sub    $0x10,%rsp
 652:   89 7d fc                mov    %edi,-0x4(%rbp)
 655:   48 89 75 f0             mov    %rsi,-0x10(%rbp)
 659:   be 7b 00 00 00          mov    $0x7b,%esi
 65e:   48 8d 3d 9f 00 00 00    lea    0x9f(%rip),%rdi        # 704 <_IO_stdin_used+0x4>
 665:   b8 00 00 00 00          mov    $0x0,%eax
 66a:   e8 b1 fe ff ff          callq  520 <printf@plt>
 66f:   b8 00 00 00 00          mov    $0x0,%eax
 674:   c9                      leaveq
 675:   c3                      retq
 676:   66 2e 0f 1f 84 00 00    nopw   %cs:0x0(%rax,%rax,1)
 67d:   00 00 00
```
