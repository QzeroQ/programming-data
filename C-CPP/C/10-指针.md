# 指针

---
## 1 指针

一个变量的(内存)地址称为该变量的“指针”，通过指针能找到以它为地址的内存单元。指针概念是构成C/C++的重要元素之一，是变量的一种类型，存放的是指定类型数据的地址，而同类型变量存放的是具体的数据。指针变量是用来存放另一个变量的地址的变量。指针是概念，指针变量是具体实现。每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号`（&）`运算符访问的地址，它表示了在内存中的一个地址。

### 地址运算符与间接运算符

- 地址运算符`&`用于获取一个变量的地址。
- 间接运算符`*`用于从指针中获取指针地址存储的值。

### 认识指针

要认识指针需要搞清楚指针的四方面类容

- 指针的类型：从语法的角度看，只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。这是指针本身所具有的类型。

```c
int *ptr;//指针的类型是int*
char *ptr;//指针的类型是char*
int **ptr;//指针的类型是int**
int (*ptr)[3];//指针的类型是int(*)[3]
int *(*ptr)[4];//指针的类型是int*(*)[4]
```

- 指针所指向的类型：当通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。从语法上看，只须把指针声明语句中的指针名字和名字左边的指针声明符`*`去掉，剩下的就是指针所指向的类型。

```c
int *ptr; //指针所指向的类型是int
char *ptr; //指针所指向的的类型是char
int **ptr; //指针所指向的的类型是int*
int (*ptr)[3]; //指针所指向的的类型是int()[3]
int *(*ptr)[4]; //指针所指向的的类型是int*()[4]

```c
- 指针的值：指针的值是指针本身存储的数值，这个值将被编译器当作一个地址，而不是一个一般的数值。一个指针指向了某块内存区域，就相当于说该指针的值是这块内存区域的首地址。
- 指针本身所占据的内存区：指针本身占了多大的内存，32平台指针的长度是4个字节，64位平台指针的长度是8个字节。

注意：

1. **指针的类型与指针所指向的类型不是同一个概念**。很多情况下却容易忽视它们的区别。指针的类型是指针自身的类型(指针类型可以被强制转换)，而指针所指向的类型是指针指向的数据（内存）的类型。
2. 指针所指向的内存区与指针所指向的类型是两个完全不同的概念。不要混淆

认识指针示例：

```c
//两个运算符：“*”（间接引用）、“[]”（下标），“[]”的优先级别大于“*”的优先级别。

//一个数组指针，只是这个指针类型不是int，而是int[4]类型的数组，解析：它首先是个指针，即*q，剩下的“int [4]”作为补充说明，即说明指针q指向一个长度为4的数组。
int (*a)[4]

//指针数组，表示一个一维指针数组，数组里面的元素都是指针类型。解析：int *p[4]，“[]”的优先级别高，所以它首先是个大小为4的数组，即p[4]；剩下的“int *”作为补充说明，即说明该数组的每一个元素为指向一个整型类型的指针。
int *a[4]
```

遇到指针从哪些方面入手

- 这个指针的类型是什么？
- 指针指的类型是什么？
- 该指针指向了哪里？

### 指针表达式

一个表达式的结果如果是一个指针，那么这个表达式就叫指针表式。

---
## 2 指针的运算

指针可以加上或者减去一个整数，指针的这种运算的意义和通常的数值的加减运算的意义是不一样的，**指针的运算单元与它指向的类型有关**。

一个指针加(减)一个整数n 后，结果是一个新的指针，运算后指针的类型相同，新的指针所指向的类型和之前的指针所指向的类型也相同。新的指针的值将比旧的值增加(减少)了` n 乘 sizeof` (旧指针所指向的类型)个字节。

---
## 3 指针常量和常量指针

### 常量指针

指向常量的指针，常量指针有如下特点：

1. 常量指针指向的对象不能通过这个指针来修改。
2. 指针还可以指向别处，因为指针本身只是个变量，可以指向任意地址，所以叫常量指针，是限制了通过这个指针修改变量的值。

声明常量指针

```c
int const* p;
const int* p;
```

### 指针常量

指针常量是一个指针，还有常量的特性。指针常量的值是指针，这个值因为是常量，所以不能被赋值。
指针本身是常量，指向的地址不可以变化,但是指向的地址所对应的内容可以变化；

声明指针常量

```c
int* const p;
```

### 指向常量的常指针

指向常量的指针常量就是一个常量，且它指向的对象也是一个常量。

声明指向常量的常指针

```c
const int* const p;
```

示例：

```c
int a = 4;
const int b = 5;

//常量指针:指向常量的指针，不能通过*cpb1给b再次赋值
int const *cpb1 = &b;
const int *cpb2 = &b;

//指针常量,pc不能再指向其他值
int* const pc = &a;
//指向常量的常指针：
const int* const cpca = &a;
const int* const cpcab = &b;
```

---
## 4 指针与数组

数组名不代表整个数组，只代表数组元素的首地址，数组的数组名可以看作一个指针。

- 指针数组
- 数组指针
- 指针数组的加减运算，注意：如果数组是常量，不允许对该数组指针进行加减运算
- 通过指针引用多维数组

```c
//示例1
int array[10]={0,1,2,3,4,5,6,7,8,9},value;
value=array[0]; //也可写成：value=*array;
value=array[3]; //也可写成：value=*(array+3);
value=array[4]; //也可写成：value=*(array+4);

//示例2
char *arr[20];//arr指向的是一个字符指针
char **parr = arr;

//示例3
int array[10];
int (*ptr)[10];//ptr是一个指针，指向的是一个长度为10的整型数组
ptr=&array;：
```

---
## 5 指针与函数

函数指针：如果在程序中定义一个函数，在编译时编译系统为函数代码分配一段存储空间，这段存空间的起始地址(入口地址)称为函数的指针。

定义函数指针：`类型名(* 指针变量名)(函数参数列表)`，例如：`int (*p)(int,int);`

指针函数相关内容：

- 指向函数的指针
- 函数指针作为函数参数
- 返回指针的函数

主要在于如何认识指针类型。

---
## 6 指针与结构体

可以声明一个指向结构类型对象的指针。对于结构体指针，可以通过`->`符号直接引用结构体的成员变量

```c
struct MyStruct{
    int a;
    int b;
    int c;
};
struct MyStruct ss={20,30,40};
struct MyStruct *ptr=&ss;
int value = ptr->c;
```

---
## 7 指针类型转换

指针可以进行强制类型转换

---
## 9 指针安全：避免错误用法

强制类型转换后，错误赋值：

```c
char s='a';
int *ptr;
ptr=(int *)&s;
*ptr=1298；//本来我们只有s一个字节的内存，现在把s后面的三个字节也修改了
```

永远不要这样做，可能会造成意想不到的结果：

```c
//定义一个指针而没有赋值，这时这个指针会指向一个未知的地址
int *tem;
//而如果此时给 *tem赋值，就会改变那个未知地址的值
*tem = *a;
```

这里会导致程序异常。因为地址10不存在：

```c
int * a = 10;
printf("%d", *a);
```

分配空间：下面代码是非常危险的，因为name是未知的内存地址，然后用户输入后导致未知
的值被覆盖，正确的做法是需要为name声明长度来分配空间。

```c
char *name;
scanf("%s",name);
```

---
## 10 指针的大小

### 1 几个基本概念

#### 字长

**在同一时间中处理二进制数的位数叫字长**。通常称处理字长为8位数据的CPU叫8位CPU，32位CPU就是在同一时间内处理字长为32位的二进制数据。二进制的每一个0或1是组成二进制的最小单位,称为一个比特（bit）。　一般说来，计算机在同一时间内处理的一组二进制数称为一个计算机的“字”，而这组二进制数的位数就是“字长”。字长与计算机的功能和用途有很大的关系， 是计算机的一个重要技术指标。字长直接反映了一台计算机的计算精度，为适应不同的要求及协调运算精度和硬件造价间的关系，大多数计算机均支持变字长运算， 即机内可实现半字长、全字长（或单字长）和双倍字长运算。在其他指标相同时，字长越大计算机的处理数据的速度就越快。早期的微机字长一般是8位和16 位，386以及更高的处理器大多是32位。目前市面上的计算机的处理器大部分已达到64位。

**字长由微处理器（CPU）对外数据通路的数据总线条数决定**。

#### 最小可寻址单位

内存的最小可寻址单位通常都是字节。也就是说一个指针地址值可对应内存中一个字节的空间。

#### 寻址空间

**寻址空间一般指的是CPU对于内存寻址的能力**。**CPU最大能查找多大范围的地址叫做寻址能力** ，CPU的寻址能力以字节为单位 （字节是最小可寻址单位），如32位寻址的CPU可以寻址2的32次方大小的地址也就是4G，这也是为什么32位寻址的CPU最大能搭配4G内存的原因 ，再多的话CPU就找不到了。

这里CPU的寻址位数是由地址总线的位数决定，32位CPU的寻址位数不一定是32位，因为32位CPU中32的意义为字长。

**有关寻址范围计算解释**，对于32位寻址的CPU，其地址值为32位的二进制数，所以可以表示的最大地址为2的32次方(即4G，最大内存空间为4GB，这里G表示数量、GB表示容量)。同时我们不难看出，一个指针的值就是一个32位的二进制数，32位对应4字节(Byte)。所以，指针的大小实际上是由CPU的寻址位数决定，而不是字长。

### 2 分析

- 32位处理器上32位操作系统的32位编译器，指针大小4字节。
- 32位处理器上32位操作系统的16位编译器，指针大小2字节。
- 32位处理器上16位操作系统的16位编译器，指针大小2字节。
- 16位处理器上16位操作系统的16位编译器，指针大小2字节。

这从结果看起来指针的大小和编译器有关？实际不是这样的，有这样的结果是因为以上几种情况，处理器当前运行模式的寻址位数是不一样的，如下：

- Intel 32位处理器32位运行模式，逻辑寻址位数32，指针也就是32位，即4个字节
- Intel 32位处理器16位虚拟机运行模式，逻辑寻址位数16，指针也就是16位，即2个字节

编译器的作用是根据目标硬件（即CPU）的特性将源程序编译为可在该硬件上运行的目标文件。如果一个编译器支持某32位的CPU，那么它就可以将源程序编译为可以在该CPU上运行的目标文件。该源程序中指针大小也会被编译器根据该CPU的寻址位数（如32位）编译选择为4字节。

综上可得：**指针大小是由当前CPU运行模式的寻址位数决定**！

---
## 引用

- [让你不再害怕指针——C指针详解(经典,非常详细)](http://blog.csdn.net/soonfly/article/details/51131141)
- [C语言中文网：指针](http://c.biancheng.net/cpp/html/72.html)
- [指针的大小到底是由谁决定的?是多少?](http://blog.sina.com.cn/s/blog_4fd9844201010n3v.html)
- [关于地址总线，字长，内存容量，寻址范围的计算](http://blog.csdn.net/u013058618/article/details/49407237)