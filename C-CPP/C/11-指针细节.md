# 指针细节

## 指针的基本概念

堆栈有栈顶指针，队列有头指针和尾指针，这些概念中的“指针”本质上是一个整数，是数组的索引，通过指针访问数组中的某个元素。这里指针有另外一个含义：**把一个变量所在的内存单元的地址保存在另外一个内存单元中，保存地址的这个内存单元称为指针，通过指针和间接寻址访问变量，这种指针在C语言中可以用一个指针类型的变量表示**。

```c
int i;
//&是取地址运算符（Address Operator），&i表示取变量i的地址，int *pi = &i;表示定义一个指向int型的指针变量pi，并用i的地址来初始化pi。
int *pi = &i;
char c;
char *pc = &c;
```

![指针](images/c_pointer.png)

## 指针类型的参数和返回值

```c
#include <stdio.h>

int *swap(int *px, int *py){
    int temp;
    temp = *px;
    *px = *py;
    *py = temp;
    return px;
}

int main(void){
    int i = 10, j = 20;
    int *p = swap(&i, &j);
    printf("now i=%d j=%d *p=%d\n", i, j, *p);
    return 0;
}
```

## 指针与数组、结构体

```c
void func(int *a){
    ...
}

void func(int a[]){
    ...
}
```

上面两个方法定义是等价的，参数写成指针形式还是数组形式对编译器来说没区别，都表示这个参数是指针，之所以规定两种形式是为了给读代码的人提供有用的信息：

- 如果这个参数指向一个元素，通常写成指针的形式。
- 如果这个参数指向一串元素中的首元素，则经常写成数组的形式。

## 指针与 const 限定符

```c
//这两种写法是一样的，a是一个指向const int型的指针，a所指向的内存单元不可改写，所以(*a)++是不允许的，但a可以改写，所以a++是允许的。
const int *a;
int const *a;

//a是一个指向int型的const指针，*a是可以改写的，但a不允许改写。
int * const a;

//a是一个指向const int型的const指针，因此*a和a都不允许改写
int const * const a;

//指向非const变量的指针或者非const变量的地址可以传给指向const变量的指针，编译器可以做隐式类型转换，例如：
char c = 'a';
const char *pc = &c;

//指向const变量的指针或者const变量的地址不可以传给指向非const变量的指针，以免透过后者意外改写了前者所指向的内存单元，例如对下面的代码编译器会报警告：
const char c = 'a';
char *pc = &c;
```

即使不用 const 限定符也能写出功能正确的程序，但良好的编程习惯应该尽可能多地使用 const，因为：

- const 给读代码的人传达非常有用的信息。比如一个函数的参数是`const char *`，你在调用这个函数时就可以放心地传给它`char *`或`const char *`指针，而不必担心指针所指的内存单元被改写。
- 尽可能多地使用 const 限定符，把不该变的都声明成只读，这样可以依靠编译器检查程序中的 Bug，防止意外改写数据。
- const 对编译器优化是一个有用的提示，编译器也许会把 const 变量优化成常量。

## 指向指针的指针与指针数组

指针可以指向基本类型，也可以指向复合类型，因此也可以指向另外一个指针变量，称为指向指针的指针。

```c
int i;
int *pi = &i;
int **ppi = &pi;
```

数组中的每个元素可以是基本类型，也可以复合类型，因此也可以是指针类型。例如定义一个数组a由10个元素组成，每个元素都是int *指针：

```c
int *a[10];
```

这称为指针数组。`int *a[10];` 和 `int **pa;` 之间的关系类似于 `int a[10];` 和 `int *pa;` 之间的关系：a 是由一种元素组成的数组，pa 则是指向这种元素的指针。所以，如果 pa 指向 a 的首元素：

```c
int *a[10];
int **pa = &a[0];
```

**main 函数标准原型**：main函数的标准原型应该是，`int main(int argc, char *argv[]);`，argc 是命令行参数的个数。而 argv 是一个指向指针的指针，为什么不是指针数组呢？因为函数原型中的 `[]` 表示指针而不表示数组，等价于`char **argv`。那为什么要写成`char *argv[]`而不写成`char**argv`呢？这样写给读代码的人提供了有用信息，`argv`不是指向单个指针，而是指向一个指针数组的首元素。数组中每个元素都是`char *`指针，指向一个命令行参数字符串。

```c
//遍历参数
#include <stdio.h>

int main(int argc, char *argv[]){
    int i;

    // 方式1
    for(i = 0; i < argc; i++){
        printf("argv[%d]=%s\n", i, argv[i]);
    }

    // 方式2：由于argv[4]是NULL，我们也可以这样循环遍历argv：
    for(i=0; argv[i] != NULL; i++){
        printf("argv[%d]=%s\n", i, argv[i]);
    }

    return 0;
}
```

## 指向数组的指针与多维数组

指针可以指向复合类型，以下定义一个指向数组的指针，该数组有 10 个 int 元素：

```c
int (*a)[10];
```

指针数组的定义`int *a[10];`相比，仅仅多了一个`()`括号。如何记住和区分这两种定义呢？我们可以认为`[]`比`*`有更高的优先级，如果`a`先和`*`结合则表示a是一个指针，如果`a`先和`[]`结合则表示`a`是一个数组。`int *a[10];`这个定义可以拆成两句：

```c
typedef int *t;
t a[10];
```

t 代表 `int *` 类型，a 则是由这种类型的元素组成的数组。`int (*a)[10];` 这个定义也可以拆成两句：

```c
typedef int t[10];
t *a;
```

t 代表由 10 个 int 组成的数组类型，a则是指向这种类型的指针。现在看指向数组的指针如何使用：

```c
int a[10];
int (*pa)[10] = &a;
```