# 指针细节

>内容来自[《Linux C编程一站式学习》](https://akaedu.github.io/book/)第23章。

## 指针的基本概念

堆栈有栈顶指针，队列有头指针和尾指针，这些概念中的“指针”本质上是一个整数，是数组的索引，通过指针访问数组中的某个元素。这里指针有另外一个含义：**把一个变量所在的内存单元的地址保存在另外一个内存单元中，保存地址的这个内存单元称为指针，通过指针和间接寻址访问变量，这种指针在C语言中可以用一个指针类型的变量表示**。

```c
int i;
int *pi = &i;
char c;
char *pc = &c;
```

![指针](images/c_pointer.png)

### 指针基本操作：`&` 与 `*`

`&` 是取地址运算符（Address Operator），`&i`表示取变量`i`的地址，`int *pi = &i;`表示定义一个指向`int`型的指针变量`pi`，并用`i`的地址来初始化`pi`。

全局变量只能用常量表达式初始化，如果定义`int p = i;`就错了，因为`i`不是常量表达式，然而用`i`的地址来初始化一个指针却没有错，因为`i`的地址是在编译链接时能确定的，而不需要到运行时才知道，`&i`是常量表达式。

如果要让 pi 指向另一个整型变量 j，可以重新对 pi 赋值，如果要改变 pi 所指向的整型变量的值，比如把变量 j 的值增加 10，可以写：

```c
pi = &j;
*pi = *pi + 10;
```

这里的`*`号是指针间接寻址运算符（Indirection Operator），`*pi`表示取指针`pi`所指向的变量的值，也称为`Dereference`操作，指针有时称为变量的引用（Reference），所以根据指针找到变量称为Dereference。

- `&`运算符的操作数必须是左值，因为只有左值才表示一个内存单元，才会有地址，运算结果是指针类型。
- `*`运算符的操作数必须是指针类型，运算结果可以做左值。所以，如果表达式E可以做左值，`*&E`和`E`等价，如果表达式`E`是指针类型，`&*E`和`E`等价。

### 指针之间的赋值

指针之间可以相互赋值，也可以用一个指针初始化另一个指针：

```c
//表示pi指向哪就让ptri也指向哪，本质上就是把变量pi所保存的地址值赋给变量ptri。

//直接赋值
int *ptri = pi;
//或者先定义，再赋值
int *ptri;
ptri = pi;
```

**指针强转**：用一个指针给另一个指针赋值时要注意，两个指针必须是同一类型的。如果`pi`是`int*`型的，`pc`是`char *`型的，`pi = pc;`这样赋值就是错误的。但是可以先强制类型转换然后赋值

```c
pi = (int *)pc;
```

现在pi指向的地址和pc一样，但是通过`*pc`只能访问到一个字节，而通过`*pi`可以访问到 4 个字节，后 3 个字节已经不属于变量 c 了，除非你很确定变量 c 的一个字节和后面 3 个字节组合而成的 int值 是有意义的，否则就不应该给 pi 这么赋值。

因此使用指针要特别小心，很容易将指针指向错误的地址，访问这样的地址可能导致段错误，可能读到无意义的值，也可能意外改写了某些数据，使得程序在随后的运行中出错。

### 野指针与 NULL 指针

有一种情况需要特别注意，定义一个指针类型的局部变量而没有初始化：

```c
int main(void){
    int *p;
    ...
    *p = 0;
    ...
}
```

在堆栈上分配的变量初始值是不确定的，也就是说指针p所指向的内存地址是不确定的，后面用`*p`访问不确定的地址就会导致不确定的后果，如果导致段错误还比较容易改正，如果意外改写了数据而导致随后的运行中出错，就很难找到错误原因了。像这种指向不确定地址的指针称为 **“野指针”（Unbound Pointer）**，为避免出现野指针，在定义指针变量时就应该给它明确的初值，或者把它初始化为 NULL：

```c
int main(void){
    int *p = NULL;
    ...
    *p = 0;
    ...
}
```

NULL在C标准库的头文件stddef.h中定义：

```c
#define NULL ((void *)0)
```

NULL 其实是把地址`0`转换成指针类型，称为空指针，它的特殊之处在于，操作系统不会把任何数据保存在地址 0 及其附近，也不会把地址`0~0xfff`的页面映射到物理内存，所以任何对地址 0 的访问都会立刻导致段错误。`*p = 0;`会导致段错误，就像放在眼前的炸弹一样很容易找到，相比之下，**野指针的错误就像埋下地雷一样，更难发现和排除，这次走过去没事，下次走过去就有事**。

### `void *`类型

在编程时经常需要一种通用指针，可以转换为任意其它类型的指针，任意其它类型的指针也可以转换为通用指针，

- 最初C语言没有`void *`类型，就把`char *`当通用指针，需要转换时就用类型转换运算符`()`。
- ANSI在将C语言标准化时引入了`void *`类型，`void*`指针与其它类型的指针之间可以隐式转换，而不必用类型转换运算符。

注意，只能定义`void *`指针，而不能定义`void`型的变量，因为`void *`指针和别的指针一样都占4个字节，而如果定义`void`型变量（也就是类型暂时不确定的变量），编译器不知道该分配几个字节给变量。同样道理，`void*`指针不能直接 Dereference，而必须先转换成别的类型的指针再做 Dereference。`void *`指针常用于函数接口，比如：

```c
void func(void *pv){
    /* *pv = 'A' is illegal */
    char *pchar = pv;
    *pchar = 'A';
}

int main(void){
    char c;
    func(&c);
    printf("%c\n", c);...
}
```

## 指针类型的参数和返回值

```c
#include <stdio.h>

int *swap(int *px, int *py){
    int temp;
    temp = *px;
    *px = *py;
    *py = temp;
    return px;
}

int main(void){
    int i = 10, j = 20;
    int *p = swap(&i, &j);
    printf("now i=%d j=%d *p=%d\n", i, j, *p);
    return 0;
}
```

## 指针与数组、结构体

```c
void func(int *a){
    ...
}

void func(int a[]){
    ...
}
```

上面两个方法定义是等价的，参数写成指针形式还是数组形式对编译器来说没区别，都表示这个参数是指针，之所以规定两种形式是为了给读代码的人提供有用的信息：

- 如果这个参数指向一个元素，通常写成指针的形式。
- 如果这个参数指向一串元素中的首元素，则经常写成数组的形式。

## 指针与 const 限定符

```c
//这两种写法是一样的，a是一个指向const int型的指针，a所指向的内存单元不可改写，所以(*a)++是不允许的，但a可以改写，所以a++是允许的。
const int *a;
int const *a;

//a是一个指向int型的const指针，*a是可以改写的，但a不允许改写。
int * const a;

//a是一个指向const int型的const指针，因此*a和a都不允许改写
int const * const a;

//指向非const变量的指针或者非const变量的地址可以传给指向const变量的指针，编译器可以做隐式类型转换，例如：
char c = 'a';
const char *pc = &c;

//指向const变量的指针或者const变量的地址不可以传给指向非const变量的指针，以免透过后者意外改写了前者所指向的内存单元，例如对下面的代码编译器会报警告：
const char c = 'a';
char *pc = &c;
```

即使不用 const 限定符也能写出功能正确的程序，但良好的编程习惯应该尽可能多地使用 const，因为：

- const 给读代码的人传达非常有用的信息。比如一个函数的参数是`const char *`，你在调用这个函数时就可以放心地传给它`char *`或`const char *`指针，而不必担心指针所指的内存单元被改写。
- 尽可能多地使用 const 限定符，把不该变的都声明成只读，这样可以依靠编译器检查程序中的 Bug，防止意外改写数据。
- const 对编译器优化是一个有用的提示，编译器也许会把 const 变量优化成常量。

## 指向指针的指针与指针数组

指针可以指向基本类型，也可以指向复合类型，因此也可以指向另外一个指针变量，称为指向指针的指针。

```c
int i;
int *pi = &i;
int **ppi = &pi;
```

数组中的每个元素可以是基本类型，也可以复合类型，因此也可以是指针类型。例如定义一个数组a由10个元素组成，每个元素都是int *指针：

```c
int *a[10];
```

这称为指针数组。`int *a[10];` 和 `int **pa;` 之间的关系类似于 `int a[10];` 和 `int *pa;` 之间的关系：a 是由一种元素组成的数组，pa 则是指向这种元素的指针。所以，如果 pa 指向 a 的首元素：

```c
int *a[10];
int **pa = &a[0];
```

**main 函数标准原型**：main函数的标准原型应该是，`int main(int argc, char *argv[]);`，argc 是命令行参数的个数。而 argv 是一个指向指针的指针，为什么不是指针数组呢？因为函数原型中的 `[]` 表示指针而不表示数组，等价于`char **argv`。那为什么要写成`char *argv[]`而不写成`char**argv`呢？这样写给读代码的人提供了有用信息，`argv`不是指向单个指针，而是指向一个指针数组的首元素。数组中每个元素都是`char *`指针，指向一个命令行参数字符串。

```c
//遍历参数
#include <stdio.h>

int main(int argc, char *argv[]){
    int i;

    // 方式1
    for(i = 0; i < argc; i++){
        printf("argv[%d]=%s\n", i, argv[i]);
    }

    // 方式2：由于argv[4]是NULL，我们也可以这样循环遍历argv：
    for(i=0; argv[i] != NULL; i++){
        printf("argv[%d]=%s\n", i, argv[i]);
    }

    return 0;
}
```

## 指向数组的指针与多维数组

指针可以指向复合类型，以下定义一个指向数组的指针，该数组有 10 个 int 元素：

```c
int (*a)[10];
```

指针数组的定义`int *a[10];`相比，仅仅多了一个`()`括号。如何记住和区分这两种定义呢？我们可以认为`[]`比`*`有更高的优先级，如果`a`先和`*`结合则表示a是一个指针，如果`a`先和`[]`结合则表示`a`是一个数组。`int *a[10];`这个定义可以拆成两句：

```c
typedef int *t;
t a[10];
```

t 代表 `int *` 类型，a 则是由这种类型的元素组成的数组。`int (*a)[10];` 这个定义也可以拆成两句：

```c
typedef int t[10];
t *a;
```

t 代表由 10 个 int 组成的数组类型，a则是指向这种类型的指针。现在看指向数组的指针如何使用：

```c
int a[10];
int (*pa)[10] = &a;
```