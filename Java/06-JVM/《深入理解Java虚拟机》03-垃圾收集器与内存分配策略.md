# 垃圾回收机制

---
## 1 垃圾回收机制概述

说起垃圾收集(Garbage Collection，GC)大部分人都以为这项技术是Java语言的产物，起始垃圾回收机制比Java更加久远，，第一门使用内存动态分配和垃圾收集技术的语言是1960年的Lisp语言。

垃圾收集主要考虑下面三个问题：

- 哪些内存需要被回收
- 什么时候进行回收
- 如何进行回收

现在垃圾收集算法已经非常成熟，但是**当需要排查各种内存溢出，内存泄漏的问时，当垃圾收集称为系统达到更高并发量的瓶颈时，我们就需要对这些自动化的技术实施必要的监控和调节**。

---
## 2 如何判断对象需要被回收

### 引用计数法

引用计数法：给对象添加一个引用计数器，每当有一个地方引用它时，计数器值就加1，当引用失败时，计数器值就减1，当计数器值为0时就表示对象可以被回收了，但是这种算法很难解决对象之间的循环引用问题。只是目前主流的Java虚拟机没有采用此种算法来管理内存。

### 可达性算法

通过一系列**GC Roots**的对象作为起始点，从这些节点开始向下搜索，搜索所走的路线称为**引用链**，当一个对象到GC Roots没有任何引用链相连时，则证明对象时不可用的。

在Java语言中，可以作为GC Roots的对象包括下面几种：

- 虚拟机栈(栈帧中的本地变量表)中引用的对象
- 方法区中类静态属性引用的对象
- 方法区常量应用的对象
- 本地方法栈中JNI引用的对象

### 再谈引用

在JDK1.2中，引用的定义是：**如果reference类型的数据中存储的数据代表的是另一来内存的起始地址，就称这块内存代表着一个引用**。这种定义很纯粹，却又很狭隘，这样定义的话，对象就只有被应用和没有被引用两种状态了。

在JDK1.2之后，Java对引用进行了扩展，将引用分为一下四种：

- Strong Reference 强引用，比如`Object obj = new Object();`，这里的obj就是强引用
- Soft Reference 软引用，用来描述一些还有用但并不是必须的对象。在内存空间不足的情况下，会回收掉此部分内存，如果还不够则会抛出内存溢出异常。使用SoftReference实现
- Weak Reference 弱引用，用来描述非必须对象，它只能生存到下一次垃圾回收前，如果一旦发生垃圾回收，它将会被回收掉。使用WeakReference来实现。
- Phantom Reference 虚引用，此种引用唯一的目的就是：能在这个对象被收集器回收时收到一个系统的通知，

### 对象的回收过程与finalize方法

即使在可达性算法分析中不可达的对象，也并不是非死不可，真正要宣告一个对象死亡，至少要经历两次标记过程：

1. 如果对象在可达性算法分析后处于不可达状态，那它将会被第一次标记且进行一次筛选，筛选的条件是对象有没有必要执行finalize方法，当对象没有覆盖finalize方法或者finalize方法已经被虚拟机调用过，则表示没有必要执行。
2. 如果对象有必要进行一次finalize方法的调用，那么这个对象将会被放置到一个F-Queu的队列中区，并在稍后有一个虚拟机创建的，优先级较低的Finalizer线程去执行它。**这里的执行是只虚拟机会触发这个方法，但不会等待其运行结束**，finalize方法是对象逃脱死亡的最后一个机会，如果在finalize方法中对象重新与引用链建立了关联，则会被移出即将回收的集合中，如果对象在这个时候还没有逃脱，则基本上它真的就被回收了。

**注意：任何一个对象的finalize方法只会被系统自动调用一次**

```java
    public class FinalizeMethod {

        private static ClassA instance = null;
    
        public static void main(String... args) throws InterruptedException {
            instance = new ClassA();
    
            instance = null;
            System.gc();
            Thread.sleep(500);//让Finalizer线程先执行
            if (instance != null) {
                instance.isAlive();
            } else {
                System.out.println("instance dead");
            }

            instance = null;
            System.gc();
            Thread.sleep(500);//让Finalizer线程先执行
            if (instance != null) {
                instance.isAlive();
            } else {
                System.out.println("instance dead");
            }
        }
    
        public static class ClassA {
    
            private void isAlive() {
                System.out.println("yes i am still alive");
            }
    
            @Override
            protected void finalize() throws Throwable {
                super.finalize();
                System.out.println("finalize run");
                instance = this;
            }
        }
    }
    
    打印结果为：
    finalize run
    yes i am still alive
    instance dead
```

### 回收方法区

方法区的垃圾收集主要包括两部分类容：废弃的常量和无用的类。

判断一个类是否无用的条件为：

- 该类的所有实例都被回收了，Java对中不存在该类的任何实例
- 加载该类的ClassLoader已经被回收了
- 该类对应的java.lang.Class对象没有任何地方被引用，无法在任何地方通过反射访问该类的方法。

虚拟机对满足上述3个条件的无用类可以进行回收，但是否回收还需要看Java虚拟机的实现，HopSpot虚拟机提供了`-Xnoclassgc`参数进行控制，还可以使用`-verbose:class -XX:+TraceClassLoading -XX:+TraceClassUnloading`查看类的加载和卸载信息。`-XX:+TraceClassUnloading`参数需要FastDebug版的虚拟机支持。

---
## 3  一些概念

### Minor GC 和 Full GC

*   Minor GC：指发生在新生代的垃圾收集动作，因为Java对象大多都具备朝生夕灭的特性，所以Minor GC非常频繁，一般回收速度也比较快。

*   Full GC：指发生在老年代的GC，出现了Major GC，经常会伴随至少一次的Minor GC（但非绝对的，在Parallel Scavenge收集器的收集策略里就有直接进行Major GC的策略选择过程）。Major GC的速度一般会比Minor GC慢10倍以上。

### 吞吐量

吞吐量就是CPU用于运行用户代码的时间与CPU总消耗时间的比值，即`吞吐量 = 运行用户代码时间 /（运行用户代码时间 + 垃圾收集时间）`。
虚拟机总共运行了100分钟，其中垃圾收集花掉1分钟，那吞吐量就是99%。

### Stop the world 概念

因为垃圾回收的时候，需要整个的引用状态保持不变，否则判定是判定垃圾，等我稍后回收的时候它又被引用了，这就全乱套了。所以，GC的时候，其他所有的程序执行处于暂停状态，卡住了。
幸运的是，这个卡顿是非常短（尤其是新生代），对程序的影响微乎其微 （关于其他GC比如并发GC之类的，在此不讨论）。所以GC的卡顿问题由此而来，也是情有可原，暂时无可避免。

### 堆内存模型

堆内存由垃圾回收器的自动内存管理系统回收：
堆内存分为两大部分：新生代和老年代。比例为1：2。

- 老年代主要存放应用程序中生命周期长的存活对象。
- 新生代又分为三个部分：一个Eden区和两个Survivor区，比例为8：1：1。
 - Eden区存放新生的对象。
 - Survivor存放每次垃圾回收后存活的对象。

### 并发与并行

- 并行（Parallel）： 指多条垃圾收集线程并行工作，但此时用户线程仍然处于等待状态。
- 并发（Concurrent）：指用户线程与垃圾收集线程同时执行（但不一定是并行的，可能会交替执行），用户程序在继续运行，而垃圾收集程序运行于另一个CPU上。

---
## 4 垃圾回收算法

### 标记清除算法(Mark-Sweep)

标记清除算法由两个过程：**标记和清除**。标记阶段主要为标记哪些对象是可以回收的，清除就是回收标记过的那部分内存空间

- 优点：简单，易实现
- 缺点：容易产生内存碎片，对于后面分配大空间时，找不到足够的空间，而主动会触发一次内存回收，增加内存回收的次数。

### 复制算法（Copying)

此方法将内存按容量分为两块，例如A、B两块，每次只使用其中的一块，当要进行回收操作时，将A中还存活的对象复制到B块中（假设上次使用A），然后对A中所有对象清空就又构成一个完整的内存块。这种方法就避免了标记清除的内存碎片问题。效率也与存活对象的多少有关，如果存活对象多，复制就多，效率就低了。

现在的商用虚拟机都采用此种算法来回收新生代，IBM公司的专门研究表明，新生代对象98%都是朝生夕死，所以并不是按照1：1等比例来划分内存空间，而是将内存划分为一块较大的Eden(伊甸)空间和两块较小的Survivor(幸存者)空间，每次使用Eden和其中一块Survivor空间，HotSpot虚拟机默认的Eden和Survivor的比例大小为8:1，也就是每次新生代可用的内存空间为90%，只有10%会被浪费掉。

如果另一块Survivor空间足够的空间存放上一次新生代GC存活下来的对象，这些对象将直接进入老年代。

### 标记整理算法 (Mark-Compact)

该算法标记阶段和Mark-Sweep一样，但是在完成标记之后，它不是直接清理可回收对象，而是将存活对象都向一端移动，然后清理掉端边界以外的内存。所以，特别适用于存活对象多，回收对象少的情况下。此种算法适用于老年代的内存收集

### 分代回收算法

分代回收算法其实不算一种新的算法，而是根据复制算法和标记整理算法的的特点综合而成。这种综合是考虑到java的语言特性的。两种老算法的适用场景：

> 复制算法：适用于存活对象很少。回收对象多
> 标记整理算法: 适用用于存活对象多，回收对象少

分代回收算法根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代（Old Generation）和新生代（Young Generation），老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，那么就可以根据不同代的特点采取最适合的收集算法。

---
## 5 HotSpot的算法实现

- [ ] todo

---
## 6 垃圾回收器

- [ ] todo


---
## 7 内存分配与回收策略

- [ ] todo

---
## 参考

- [理解Java垃圾回收机制](http://www.jayfeng.com/2016/03/11/%E7%90%86%E8%A7%A3Java%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%9C%BA%E5%88%B6/)
- [JAVA垃圾回收机制](http://www.wxtlife.com/2016/04/25/java-jvm-gc/)
- generation 一代
- tenured 终身，tenured generation 老年代
- new generation 新生代

