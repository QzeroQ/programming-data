# 并发工具

## 1 Semaphore

### Semaphore 简介

- Semaphore 即 **信号量**。
- 信号量是由大名鼎鼎的计算机科学家迪杰斯特拉（Dijkstra）于 1965 年提出，在这之后的 15 年，信号量一直都是并发编程领域的终结者。直到 1980 年管程被提出来，我们才有了第二选择。
- 目前几乎所有支持并发编程的语言都支持信号量机制。

### Semaphore 模型

Semaphore 模型包括：**一个计数器，一个等待队列，三个方法**

- 计数器和等待队列对外是透明的。
- 只能通过信号量模型提供的三个方法来访问它们。

三个方法分别是：

- `init()`：设置计数器的初始值。
- `down()`：计数器的值减 1；如果此时计数器的值小于 0，则当前线程将被阻塞，否则当前线程可以继续执行。
- `up()`：计数器的值加 1；如果此时计数器的值小于或者等于 0，则唤醒等待队列中的一个线程，并将其从等待队列中移除。

**原子性**：init()、down() 和 up() 三个方法都是原子性的，并且这个原子性是由信号量模型的实现方保证的。JDK 中的信号量模型由 `java.util.concurrent.Semaphore` 实现。

我们可以通过下面代码来理解信号量模型：

```java

class Semaphore{
  // 计数器
  int count;
  // 等待队列
  Queue queue;

  // 初始化操作
  Semaphore(int c){
    this.count=c;
  }
  
  void down(){
    this.count--;
    if(this.count<0){
      //将当前线程插入等待队列
      //阻塞当前线程
    }
  }

  void up(){
    this.count++;
    if(this.count<=0) {
      //移除等待队列中的某个线程T
      //唤醒线程T
    }
  }
}
```

- 信号量模型里面，down()、up() 这两个操作历史上最早称为 P 操作和 V 操作，所以信号量模型也被称为 PV 原语
- 在 Java SDK 并发包里，down() 和 up() 对应的是 acquire() 和 release()。

### Semaphore 实现限流器

Semaphore 相较于 Lock 的特殊之处在于，**Semaphore 可以允许多个线程访问一个临界区**，可以理解为一个限流器。

**限流器的使用场景**：比较常见的需求就是我们工作中遇到的各种池化资源，例如连接池、对象池、线程池等等。对于数据库连接池，在同一时刻，一定是允许多个线程同时使用连接池的，每个连接在被释放前，是不允许其他线程使用的。

**利用信号量，实现对“对象池”进行限流**：所谓对象池，指的是一次性创建出 N 个对象，之后所有的线程重复利用这 N 个对象，对象在被释放前，是不允许其他线程使用的。

```java
/**对象池*/
class ObjPool<T, R> {

  final List<T> pool;
  // 用信号量实现限流器
  final Semaphore sem;

  // 构造函数
  ObjPool(int size, T t){
    pool = new Vector<T>(){};
    for(int i=0; i<size; i++){
      pool.add(t);
    }
    sem = new Semaphore(size);
  }

  // 利用对象池的对象，调用func
  R exec(Function<T,R> func) {
    T t = null;
    sem.acquire();
    try {
      t = pool.remove(0);
      return func.apply(t);
    } finally {
      pool.add(t);
      sem.release();
    }
  }
}

public static void main(String... args){
    // 创建对象池
    ObjPool<Long, String> pool = new ObjPool<Long, String>(10, 2);

    // 通过对象池获取t，之后执行  
    pool.exec(t -> {
        System.out.println(t);
        return t.toString();
    });
}
```

注意，对象保存在了 Vector 中，Vector 是 Java 提供的线程安全的容器，如果我们把 Vector 换成 ArrayList，是否可以呢？答案是不行的，因为信号量支持多个线程进入临界区，执行 list 的 add 和 remove 方法时可能是多线程并发执行。

### Semaphore 总结

1. 信号量在 Java 语言里面名气并不算大，Java 在并发编程领域走的很快，重点支持的还是管程模型。
2. 管程模型理论上解决了信号量模型的一些不足，主要体现在易用性和工程化方面，例如用信号量解决我们曾经提到过的阻塞队列问题，就比管程模型麻烦很多。
3. 信号量可以实现的独特功能就是同时允许多个线程进入临界区，但是信号量不能做的就是同时唤醒多个线程去争抢锁，只能唤醒一个阻塞中的线程，而且信号量模型是没有 Condition 的概念的，即阻塞线程被醒了直接就运行了而不会去检查此时临界条件是否已经不满足了，基于此考虑信号量模型才会设计出只能让一个线程被唤醒，否则就会出现因为缺少 Condition 检查而带来的线程安全问题。正因为缺失了 Condition，所以用信号量来实现阻塞队列就很麻烦，因为要自己实现类似 Condition 的逻辑。

## 2 ReadWriteLock

## 3 StampedLock

## 4 CountDownLatch

## 5 CyclicBarrier
