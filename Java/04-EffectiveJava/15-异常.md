
---
# 第57条：只针对异常的情况才使用异常

```java
    try{
       int i = 0;
       while(true){
          range[i++].climb();
       }
    }catch(ArrayIndexOutOfBoundsException e){
    
    }
```
避免异常用于上面代码。

- 异常的机制的设计初衷是用于不正常的情形，所以很少有JVM的实现试图对其进行优化
- 把代码放在try-catch代码块中，反而阻止了JVM实现对其进行优化


上面基于异常的循环模式不仅模糊了代码的意图，降低了性能，甚至不能保证其进行正常的工作。(如果出现了不相关的bug，这个模式会悄悄的失效)

所以：异常应该只用于异常的情况下：他们永远不应该用于正常的控制流

---
# 第58条：对可恢复的情况使用受检异常，对编程错误使用运行时异常

java语言规范提供了三种可抛出的结构：

- 受检的异常checked exception
- 运行时异常run time exception
- 错误error

如果发生异常，程序继续执行下去有害无益，应该使用运行时异常。

---
# 第59条：避免不必要的使用受检的异常

- 如果正确的API并不能阻止这种异常情况的产生
- 一旦产生异常，程序要可以立即采取有用的行动

除非这两个条件都成立，否则更适合使用未受检异常。

---
# 第60条：优先使用标准的异常

```
    IllegalArgumentException：非null的参数值不正确
    IllegalStateException：对方法调用而言，对象状态不合适
    NullPointerException：禁止使用null的情况下参数值为null
    IndexOutOfBoundsException：下表越界
    ConcurrentModificationException：在禁止并发修改的情况下，检查到对象发生了并发修改
    UnsupportedOperationException：当不支持请求的操作时
```

---
# 第61条：抛出以抽象相对于的异常

合理使用**异常转义**

---
# 第62条：每个方法抛出的异常都要有文档

---
# 第63条：在细节中包含能捕获失败的信息

---
# 第64条：努力保证失败操作原子性

一般而言，**失败的方法调用应该是对象保存在被调用之前的状态**。

措施：

- 优先检查参数有效性
- 调整处理过程的顺序
- 编写恢复代码
- 临时拷贝

---
# 第65条：不要忽略异常

- 空的catch块会使异常到不到应有的目的。
- 只是应该有注释说明，为什么可以忽略
