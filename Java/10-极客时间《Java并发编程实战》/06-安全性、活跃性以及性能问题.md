# 安全性、活跃性以及性能问题

并发编程中我们需要注意的问题有很多，主要有三个方面，分别是：

- 安全性问题
- 活跃性问题
- 性能问题

## 1 安全性问题

### 什么是安全性问题

- 在并发编程领域，我们衡量一个类时，通常会问：“这个方法不是线程安全的，这个类不是线程安全的？”
- 什么是线程安全？其实本质上就是正确性，而正确性的含义就是**程序按照我们期望的执行**，不要让我们感到意外。
- 并发 Bug 的三个主要源头：原子性问题、可见性问题和有序性问题。理论上线程安全的程序，就要避免出现原子性问题、可见性问题和有序性问题。

 安全性问题即在并发条件下，程序能否按照我们的期望去执行。

### 什么情况下需要考虑线程安全？

- 不是所有的代码都需要认真分析一遍是否存在原子性问题、可见性问题和有序性问题。
- 只有 **存在共享数据并且该数据会发生变化，通俗地讲就是有多个线程会同时读写同一数据** 才需要考虑线程。

不存在共享数据，即可以保证线程安全，此类技术有很多实现：

- 线程本地存储（Thread Local Storage，TLS）
- 不变模式

但是，现实情况下，必须共享会发生变化的数据的应用场景还是很多的。

### 安全性问题——数据竞争

**数据竞争（Data Race）**：当多个线程同时访问同一数据，并且至少有一个线程会写这个数据的时候，如果我们不采取防护措施，那么就会导致并发 Bug。

参考下面代码，当多个线程调用时候就会发生数据竞争:

```java
public class Test {

  private long count = 0;

  void add10K() {
    int idx = 0;
    while(idx++ < 10000) {
      count += 1;
    }
  }

}
```

### 安全性问题——竞态条件

不是简单地加锁就能避免所有并发问题，参考下面程序：

```java
public class Test {

  private long count = 0;

  synchronized long get(){
    return count；
  }

  synchronized void set(long v){
    count = v;
  }


  void add10K() {
    int idx = 0;
    while(idx++ < 10000) {
      //get() + 1 存在静态条件。
      set(get()+1)
    }
  }
}
```

这个程序也不是安全的，`set(get() + 1)` 存在安全隐患，虽然我们给所有访问 count 的地方都加了锁，避免了数据竞争，但是程序的正确性依赖于线程的执行顺序，如果两个线程是先后执行 `set(get()+1)` 那么程序结构是正确的，但如果两个线程同时执行了 `get()+1` 再去 `set()`， 那程序结果就是错误的，丢失了一次 `+1` 操作，这种问题，叫 **竞态条件（Race Condition）**，即 **程序的执行结果依赖线程执行的顺序**。

#### 转账中的竞态条件

```java
class Account {

  private int balance;

  // 转账
  void transfer(Account target, int amt){
    if (this.balance > amt) {
      this.balance -= amt;
      target.balance += amt;
    }
  }

}
```

银行转账是不允许超额转出的，假设  A 账户余额 150 元，两个线程都执行从 A 账户转出金额 150 元，如果两个线程同时执行完 `if (this.balance > amt)` 这一行，那么这里的判断条件就没有起到作用，两个线程都从 A 账户转出 150 元，就导致账户余额异常了。

#### 如何理解理解竞态条件

在并发场景中，程序的执行依赖于某个状态变量，类似于下面伪代码：

```java
if (状态变量 满足 执行条件) {
    执行操作
}
```

1. 当某个线程发现状态变量满足执行条件后，开始执行操作；
2. 就在这个线程执行操作的时候，其他线程同时修改了状态变量，导致状态变量不满足执行条件了。

个人理解：**线程执行操作的判断操作，与线程将要执行的操作，不同原子性的，而线程将要执行的操作又会导致判断条件的结果发生变化，这个将会导致判断条件的结果发生变化操作，可能被其他线程抢先执行**。

### 解决数据竞争和竞态条件问题——锁

面对数据竞争和竞态条件问题，该如何保证线程的安全性？其实这两类问题，都可以用互斥这个技术方案，即加锁技术。
