# 互斥锁

## 1 解决原子性问题

### 如何解决原子性问题

- 禁止线程切换：仅在单核 CPU 上有效。
- 使用互斥锁。

### 使用互斥锁解决原子性问题

- 什么是互斥：“同一时刻只有一个线程执行”，我们称之为互斥。只要保证对共享资源的操作是互斥的，无论是单核 CPU 还是多核 CPU，就都能保证原子性。
- 什么是临界区：我们把一段需要互斥执行的代码称为临界区。线程在进入临界区之前，首先尝试加锁 `lock()`，如果成功，则进入临界区，此时我们称这个线程持有锁；否则就等待，直到持有锁的线程解锁。

### 正确的锁模型

锁和锁要保护的资源是有对应关系的，在并发编程中，我们要时刻注意这一点。

### Java 语言提供的锁技术：synchronized

- synchronized 是 Java 在语言层面提供的互斥原语。
- synchronized 对加锁的方法或代码块自动加锁和解锁。

注意下面代码：

```java
class SafeCalc {
  long value = 0L;
  long get() {
    return value;
  }
  synchronized void addOne() {
    value += 1;
  }
}
```

上面 addOne 操作是否对 get 可见？答案是不可见的，get 方法并没有被加锁。

### 锁和受保护资源的关系

受保护资源和锁之间的关联关系非常重要，一个合理的关系是：**受保护资源和锁之间的关联关系是 N:1 的关系**。

- 不要拿多个锁来保护一个资源。
- 同一把锁来保护多个资源。

## 2 如何用一把锁保护多个资源？

### 保护没有关联关系的多个资源

对于没有关联关系的多个资源，应该采用多个锁分别进行保护，因为使用同一个锁保护多个资源会降低性能（对这个多个变量的操作都是串行的），**用不同的锁对受保护资源进行精细化管理，能够提升性能。这种锁还有个名字，叫细粒度锁**。

### 保护有关联关系的多个资源

对于有关联关系的多个资源，锁必须能覆盖所有受保护资源，此时应该使用粗粒度锁。

### 原子性的本质

“原子性”的本质是什么？其实不是不可分割，不可分割只是外在表现，其本质是多个资源间有一致性的要求，**操作的中间状态对外不可见**。例如，在 32 位的机器上写 long 型变量有中间状态（只写了 64 位中的 32 位），在银行转账的操作中也有中间状态（账户 A 减少了 100，账户 B 还没来得及发生变化）。所以**解决原子性问题，是要保证中间状态对外不可见**。
